The system is: Linux - 2.6.32-431.el6.i686 - i686
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /usr/bin/gcc 
Build flags: 
Id flags: 

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is GNU, found in "/home/lau/cmake-2.8.10.2/CMakeFiles/2.8.10.2/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /usr/bin/g++ 
Build flags: 
Id flags: 

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is GNU, found in "/home/lau/cmake-2.8.10.2/CMakeFiles/2.8.10.2/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2246785363/fast"
gmake -f CMakeFiles/cmTryCompileExec2246785363.dir/build.make CMakeFiles/cmTryCompileExec2246785363.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2246785363.dir/testCCompiler.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2246785363.dir/testCCompiler.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTryCompileExec2246785363
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2246785363.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2246785363.dir/testCCompiler.c.o  -o cmTryCompileExec2246785363 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Detecting C compiler ABI info compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3293852284/fast"
gmake -f CMakeFiles/cmTryCompileExec3293852284.dir/build.make CMakeFiles/cmTryCompileExec3293852284.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CMakeCCompilerABI.c
Linking C executable cmTryCompileExec3293852284
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3293852284.dir/link.txt --verbose=1
/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3293852284 -rdynamic  
Using built-in specs.
Target: i686-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch=i686 --build=i686-redhat-linux
Thread model: posix
gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) 
COMPILER_PATH=/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec3293852284' '-rdynamic' '-mtune=generic' '-march=i686'
 /usr/libexec/gcc/i686-redhat-linux/4.4.7/collect2 --eh-frame-hdr --build-id -m elf_i386 --hash-style=gnu -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec3293852284 /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crt1.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crti.o /usr/lib/gcc/i686-redhat-linux/4.4.7/crtbegin.o -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7/../../.. CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/i686-redhat-linux/4.4.7/crtend.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crtn.o
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/gmake "cmTryCompileExec3293852284/fast"]
  ignore line: [gmake -f CMakeFiles/cmTryCompileExec3293852284.dir/build.make CMakeFiles/cmTryCompileExec3293852284.dir/build]
  ignore line: [gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp']
  ignore line: [/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building C object CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o]
  ignore line: [/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CMakeCCompilerABI.c]
  ignore line: [Linking C executable cmTryCompileExec3293852284]
  ignore line: [/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3293852284.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3293852284 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [Target: i686-redhat-linux]
  ignore line: [Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch=i686 --build=i686-redhat-linux]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) ]
  ignore line: [COMPILER_PATH=/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec3293852284' '-rdynamic' '-mtune=generic' '-march=i686']
  link line: [ /usr/libexec/gcc/i686-redhat-linux/4.4.7/collect2 --eh-frame-hdr --build-id -m elf_i386 --hash-style=gnu -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec3293852284 /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crt1.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crti.o /usr/lib/gcc/i686-redhat-linux/4.4.7/crtbegin.o -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7/../../.. CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/i686-redhat-linux/4.4.7/crtend.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crtn.o]
    arg [/usr/libexec/gcc/i686-redhat-linux/4.4.7/collect2] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [--build-id] ==> ignore
    arg [-m] ==> ignore
    arg [elf_i386] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib/ld-linux.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec3293852284] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crt1.o] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crti.o] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> dir [/usr/lib/gcc/i686-redhat-linux/4.4.7]
    arg [-L/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> dir [/usr/lib/gcc/i686-redhat-linux/4.4.7]
    arg [-L/usr/lib/gcc/i686-redhat-linux/4.4.7/../../..] ==> dir [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../..]
    arg [CMakeFiles/cmTryCompileExec3293852284.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/crtend.o] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crtn.o] ==> ignore
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  collapse dir [/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> [/usr/lib/gcc/i686-redhat-linux/4.4.7]
  collapse dir [/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> [/usr/lib/gcc/i686-redhat-linux/4.4.7]
  collapse dir [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../..] ==> [/usr/lib]
  implicit libs: [c]
  implicit dirs: [/usr/lib/gcc/i686-redhat-linux/4.4.7;/usr/lib]


Determining if the CXX compiler works passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec457055324/fast"
gmake -f CMakeFiles/cmTryCompileExec457055324.dir/build.make CMakeFiles/cmTryCompileExec457055324.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec457055324.dir/testCXXCompiler.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec457055324.dir/testCXXCompiler.cxx.o -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTryCompileExec457055324
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec457055324.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec457055324.dir/testCXXCompiler.cxx.o  -o cmTryCompileExec457055324 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4052425275/fast"
gmake -f CMakeFiles/cmTryCompileExec4052425275.dir/build.make CMakeFiles/cmTryCompileExec4052425275.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o -c /home/lau/cmake-2.8.10.2/Modules/CMakeCXXCompilerABI.cpp
Linking CXX executable cmTryCompileExec4052425275
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4052425275.dir/link.txt --verbose=1
/usr/bin/g++        -v CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec4052425275 -rdynamic  
Using built-in specs.
Target: i686-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch=i686 --build=i686-redhat-linux
Thread model: posix
gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) 
COMPILER_PATH=/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec4052425275' '-rdynamic' '-shared-libgcc' '-mtune=generic' '-march=i686'
 /usr/libexec/gcc/i686-redhat-linux/4.4.7/collect2 --eh-frame-hdr --build-id -m elf_i386 --hash-style=gnu -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec4052425275 /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crt1.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crti.o /usr/lib/gcc/i686-redhat-linux/4.4.7/crtbegin.o -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7/../../.. CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/i686-redhat-linux/4.4.7/crtend.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crtn.o
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/gmake "cmTryCompileExec4052425275/fast"]
  ignore line: [gmake -f CMakeFiles/cmTryCompileExec4052425275.dir/build.make CMakeFiles/cmTryCompileExec4052425275.dir/build]
  ignore line: [gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp']
  ignore line: [/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building CXX object CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/usr/bin/g++     -o CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o -c /home/lau/cmake-2.8.10.2/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Linking CXX executable cmTryCompileExec4052425275]
  ignore line: [/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4052425275.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/g++        -v CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec4052425275 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [Target: i686-redhat-linux]
  ignore line: [Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch=i686 --build=i686-redhat-linux]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) ]
  ignore line: [COMPILER_PATH=/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/:/usr/libexec/gcc/i686-redhat-linux/4.4.7/:/usr/libexec/gcc/i686-redhat-linux/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/:/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec4052425275' '-rdynamic' '-shared-libgcc' '-mtune=generic' '-march=i686']
  link line: [ /usr/libexec/gcc/i686-redhat-linux/4.4.7/collect2 --eh-frame-hdr --build-id -m elf_i386 --hash-style=gnu -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec4052425275 /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crt1.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crti.o /usr/lib/gcc/i686-redhat-linux/4.4.7/crtbegin.o -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7 -L/usr/lib/gcc/i686-redhat-linux/4.4.7/../../.. CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/i686-redhat-linux/4.4.7/crtend.o /usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crtn.o]
    arg [/usr/libexec/gcc/i686-redhat-linux/4.4.7/collect2] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [--build-id] ==> ignore
    arg [-m] ==> ignore
    arg [elf_i386] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib/ld-linux.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec4052425275] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crt1.o] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crti.o] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> dir [/usr/lib/gcc/i686-redhat-linux/4.4.7]
    arg [-L/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> dir [/usr/lib/gcc/i686-redhat-linux/4.4.7]
    arg [-L/usr/lib/gcc/i686-redhat-linux/4.4.7/../../..] ==> dir [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../..]
    arg [CMakeFiles/cmTryCompileExec4052425275.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/crtend.o] ==> ignore
    arg [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../../crtn.o] ==> ignore
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  collapse dir [/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> [/usr/lib/gcc/i686-redhat-linux/4.4.7]
  collapse dir [/usr/lib/gcc/i686-redhat-linux/4.4.7] ==> [/usr/lib/gcc/i686-redhat-linux/4.4.7]
  collapse dir [/usr/lib/gcc/i686-redhat-linux/4.4.7/../../..] ==> [/usr/lib]
  implicit libs: [stdc++;m;c]
  implicit dirs: [/usr/lib/gcc/i686-redhat-linux/4.4.7;/usr/lib]


Determining if the include file iostream exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec934055200/fast"
gmake -f CMakeFiles/cmTryCompileExec934055200.dir/build.make CMakeFiles/cmTryCompileExec934055200.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec934055200.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec934055200.dir/CheckIncludeFile.cxx.o -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec934055200
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec934055200.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec934055200.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec934055200 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has std namespace passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1910334663/fast"
gmake -f CMakeFiles/cmTryCompileExec1910334663.dir/build.make CMakeFiles/cmTryCompileExec1910334663.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1910334663.dir/TestForSTDNamespace.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec1910334663.dir/TestForSTDNamespace.cxx.o -c /home/lau/cmake-2.8.10.2/Modules/TestForSTDNamespace.cxx
Linking CXX executable cmTryCompileExec1910334663
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1910334663.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec1910334663.dir/TestForSTDNamespace.cxx.o  -o cmTryCompileExec1910334663 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler understands ansi for scopes passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec763626363/fast"
gmake -f CMakeFiles/cmTryCompileExec763626363.dir/build.make CMakeFiles/cmTryCompileExec763626363.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec763626363.dir/TestForAnsiForScope.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec763626363.dir/TestForAnsiForScope.cxx.o -c /home/lau/cmake-2.8.10.2/Modules/TestForAnsiForScope.cxx
Linking CXX executable cmTryCompileExec763626363
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec763626363.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec763626363.dir/TestForAnsiForScope.cxx.o  -o cmTryCompileExec763626363 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has sstream passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1013351529/fast"
gmake -f CMakeFiles/cmTryCompileExec1013351529.dir/build.make CMakeFiles/cmTryCompileExec1013351529.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1013351529.dir/TestForSSTREAM.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec1013351529.dir/TestForSSTREAM.cxx.o -c /home/lau/cmake-2.8.10.2/Modules/TestForSSTREAM.cxx
Linking CXX executable cmTryCompileExec1013351529
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1013351529.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec1013351529.dir/TestForSSTREAM.cxx.o  -o cmTryCompileExec1013351529 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the unsetenv exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2782892426/fast"
gmake -f CMakeFiles/cmTryCompileExec2782892426.dir/build.make CMakeFiles/cmTryCompileExec2782892426.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2782892426.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2782892426.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2782892426
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2782892426.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2782892426.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2782892426 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdlib.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef unsetenv
  return ((int*)(&unsetenv))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Checking whether header cstdio is available compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1467725908/fast"
gmake -f CMakeFiles/cmTryCompileExec1467725908.dir/build.make CMakeFiles/cmTryCompileExec1467725908.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1467725908.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDIO  -o CMakeFiles/cmTryCompileExec1467725908.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1467725908
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1467725908.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1467725908.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1467725908 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for Large File Support compiled and ran with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1241660856/fast"
gmake -f CMakeFiles/cmTryCompileExec1241660856.dir/build.make CMakeFiles/cmTryCompileExec1241660856.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1241660856.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_CXX_HAS_CSTDIO=1 -DTEST_KWSYS_LFS_WORKS  -o CMakeFiles/cmTryCompileExec1241660856.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1241660856
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1241660856.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1241660856.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1241660856 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether STL classes are in std namespace compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1992424888/fast"
gmake -f CMakeFiles/cmTryCompileExec1992424888.dir/build.make CMakeFiles/cmTryCompileExec1992424888.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1992424888.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAVE_STD  -o CMakeFiles/cmTryCompileExec1992424888.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1992424888
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1992424888.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1992424888.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1992424888 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI stream headers are available compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3674709299/fast"
gmake -f CMakeFiles/cmTryCompileExec3674709299.dir/build.make CMakeFiles/cmTryCompileExec3674709299.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3674709299.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_ANSI  -o CMakeFiles/cmTryCompileExec3674709299.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3674709299
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3674709299.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3674709299.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3674709299 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI streams are in std namespace compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1077988701/fast"
gmake -f CMakeFiles/cmTryCompileExec1077988701.dir/build.make CMakeFiles/cmTryCompileExec1077988701.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1077988701.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAVE_STD  -o CMakeFiles/cmTryCompileExec1077988701.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1077988701
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1077988701.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1077988701.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1077988701 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI string stream is available compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2989555175/fast"
gmake -f CMakeFiles/cmTryCompileExec2989555175.dir/build.make CMakeFiles/cmTryCompileExec2989555175.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2989555175.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_SSTREAM  -o CMakeFiles/cmTryCompileExec2989555175.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2989555175
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2989555175.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2989555175.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2989555175 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether header cstddef is available compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec363016442/fast"
gmake -f CMakeFiles/cmTryCompileExec363016442.dir/build.make CMakeFiles/cmTryCompileExec363016442.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec363016442.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDDEF  -o CMakeFiles/cmTryCompileExec363016442.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec363016442
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec363016442.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec363016442.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec363016442 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl string has operator!= for char* compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1876302614/fast"
gmake -f CMakeFiles/cmTryCompileExec1876302614.dir/build.make CMakeFiles/cmTryCompileExec1876302614.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1876302614.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_STRING_HAVE_NEQ_CHAR  -o CMakeFiles/cmTryCompileExec1876302614.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1876302614
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1876302614.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1876302614.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1876302614 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has iterator_traits compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2923702946/fast"
gmake -f CMakeFiles/cmTryCompileExec2923702946.dir/build.make CMakeFiles/cmTryCompileExec2923702946.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2923702946.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ITERATOR_TRAITS  -o CMakeFiles/cmTryCompileExec2923702946.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2923702946
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2923702946.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2923702946.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2923702946 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has standard template allocator compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1413354145/fast"
gmake -f CMakeFiles/cmTryCompileExec1413354145.dir/build.make CMakeFiles/cmTryCompileExec1413354145.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1413354145.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_TEMPLATE  -o CMakeFiles/cmTryCompileExec1413354145.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1413354145
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1413354145.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1413354145.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1413354145 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for rebind member of stl allocator compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec591154741/fast"
gmake -f CMakeFiles/cmTryCompileExec591154741.dir/build.make CMakeFiles/cmTryCompileExec591154741.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec591154741.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_REBIND  -o CMakeFiles/cmTryCompileExec591154741.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec591154741
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec591154741.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec591154741.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec591154741 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl containers support allocator objects. compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1440507699/fast"
gmake -f CMakeFiles/cmTryCompileExec1440507699.dir/build.make CMakeFiles/cmTryCompileExec1440507699.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1440507699.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_OBJECTS  -o CMakeFiles/cmTryCompileExec1440507699.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1440507699
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1440507699.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1440507699.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1440507699 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ios has binary openmode compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2762683609/fast"
gmake -f CMakeFiles/cmTryCompileExec2762683609.dir/build.make CMakeFiles/cmTryCompileExec2762683609.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2762683609.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAVE_BINARY  -o CMakeFiles/cmTryCompileExec2762683609.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2762683609
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2762683609.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2762683609.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2762683609 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for member template support compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1526470542/fast"
gmake -f CMakeFiles/cmTryCompileExec1526470542.dir/build.make CMakeFiles/cmTryCompileExec1526470542.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1526470542.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_MEMBER_TEMPLATES  -o CMakeFiles/cmTryCompileExec1526470542.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1526470542
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1526470542.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1526470542.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1526470542 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for standard template specialization syntax compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2510032733/fast"
gmake -f CMakeFiles/cmTryCompileExec2510032733.dir/build.make CMakeFiles/cmTryCompileExec2510032733.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2510032733.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_FULL_SPECIALIZATION  -o CMakeFiles/cmTryCompileExec2510032733.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2510032733
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2510032733.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2510032733.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2510032733 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether argument dependent lookup is supported compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1341574650/fast"
gmake -f CMakeFiles/cmTryCompileExec1341574650.dir/build.make CMakeFiles/cmTryCompileExec1341574650.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1341574650.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ARGUMENT_DEPENDENT_LOOKUP  -o CMakeFiles/cmTryCompileExec1341574650.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1341574650
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1341574650.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1341574650.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1341574650 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether struct stat has st_mtim member compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec441897148/fast"
gmake -f CMakeFiles/cmTryCompileExec441897148.dir/build.make CMakeFiles/cmTryCompileExec441897148.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec441897148.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STAT_HAS_ST_MTIM  -o CMakeFiles/cmTryCompileExec441897148.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec441897148
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec441897148.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec441897148.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec441897148 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C++ compiler has 'long long' compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec516603740/fast"
gmake -f CMakeFiles/cmTryCompileExec516603740.dir/build.make CMakeFiles/cmTryCompileExec516603740.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec516603740.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_LONG_LONG  -o CMakeFiles/cmTryCompileExec516603740.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec516603740
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec516603740.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec516603740.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec516603740 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for C type size macros compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec966822718/fast"
gmake -f CMakeFiles/cmTryCompileExec966822718.dir/build.make CMakeFiles/cmTryCompileExec966822718.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec966822718.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_TYPE_MACROS  -o CMakeFiles/cmTryCompileExec966822718.dir/kwsysPlatformTestsC.c.o   -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec966822718
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec966822718.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec966822718.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec966822718 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file sys/types.h exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2910843660/fast"
gmake -f CMakeFiles/cmTryCompileExec2910843660.dir/build.make CMakeFiles/cmTryCompileExec2910843660.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2910843660.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2910843660.dir/CheckIncludeFile.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec2910843660
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2910843660.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2910843660.dir/CheckIncludeFile.c.o  -o cmTryCompileExec2910843660 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file stdint.h exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1536884790/fast"
gmake -f CMakeFiles/cmTryCompileExec1536884790.dir/build.make CMakeFiles/cmTryCompileExec1536884790.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1536884790.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1536884790.dir/CheckIncludeFile.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1536884790
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1536884790.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1536884790.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1536884790 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file stddef.h exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3078267806/fast"
gmake -f CMakeFiles/cmTryCompileExec3078267806.dir/build.make CMakeFiles/cmTryCompileExec3078267806.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3078267806.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3078267806.dir/CheckIncludeFile.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3078267806
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3078267806.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3078267806.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3078267806 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of char passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1634515815/fast"
gmake -f CMakeFiles/cmTryCompileExec1634515815.dir/build.make CMakeFiles/cmTryCompileExec1634515815.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1634515815.dir/KWSYS_SIZEOF_CHAR.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1634515815.dir/KWSYS_SIZEOF_CHAR.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/KWSYS_SIZEOF_CHAR.c
Linking C executable cmTryCompileExec1634515815
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1634515815.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1634515815.dir/KWSYS_SIZEOF_CHAR.c.o  -o cmTryCompileExec1634515815 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Checking whether char is signed compiled and ran with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec975938396/fast"
gmake -f CMakeFiles/cmTryCompileExec975938396.dir/build.make CMakeFiles/cmTryCompileExec975938396.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec975938396.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CHAR_IS_SIGNED  -o CMakeFiles/cmTryCompileExec975938396.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec975938396
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec975938396.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec975938396.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec975938396 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if istream supports long long compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2532675212/fast"
gmake -f CMakeFiles/cmTryCompileExec2532675212.dir/build.make CMakeFiles/cmTryCompileExec2532675212.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2532675212.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_ISTREAM_LONG_LONG  -o CMakeFiles/cmTryCompileExec2532675212.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2532675212
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2532675212.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2532675212.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2532675212 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if ostream supports long long compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec813939098/fast"
gmake -f CMakeFiles/cmTryCompileExec813939098.dir/build.make CMakeFiles/cmTryCompileExec813939098.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec813939098.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_OSTREAM_LONG_LONG  -o CMakeFiles/cmTryCompileExec813939098.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec813939098
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec813939098.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec813939098.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec813939098 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ptrdiff_t in stddef.h compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1757645485/fast"
gmake -f CMakeFiles/cmTryCompileExec1757645485.dir/build.make CMakeFiles/cmTryCompileExec1757645485.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1757645485.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_PTRDIFF_T  -o CMakeFiles/cmTryCompileExec1757645485.dir/kwsysPlatformTestsC.c.o   -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec1757645485
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1757645485.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1757645485.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec1757645485 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ssize_t in unistd.h compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec693873175/fast"
gmake -f CMakeFiles/cmTryCompileExec693873175.dir/build.make CMakeFiles/cmTryCompileExec693873175.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec693873175.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_SSIZE_T  -o CMakeFiles/cmTryCompileExec693873175.dir/kwsysPlatformTestsC.c.o   -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec693873175
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec693873175.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec693873175.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec693873175 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has setenv compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3718617563/fast"
gmake -f CMakeFiles/cmTryCompileExec3718617563.dir/build.make CMakeFiles/cmTryCompileExec3718617563.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3718617563.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_SETENV  -o CMakeFiles/cmTryCompileExec3718617563.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3718617563
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3718617563.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3718617563.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3718617563 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has unsetenv compiled with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2292987376/fast"
gmake -f CMakeFiles/cmTryCompileExec2292987376.dir/build.make CMakeFiles/cmTryCompileExec2292987376.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2292987376.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_UNSETENV  -o CMakeFiles/cmTryCompileExec2292987376.dir/kwsysPlatformTestsCXX.cxx.o -c /home/lau/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2292987376
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2292987376.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2292987376.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2292987376 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the function gethostbyname exists in the c passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1752136972/fast"
gmake -f CMakeFiles/cmTryCompileExec1752136972.dir/build.make CMakeFiles/cmTryCompileExec1752136972.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1752136972.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=gethostbyname   -o CMakeFiles/cmTryCompileExec1752136972.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1752136972
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1752136972.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=gethostbyname    CMakeFiles/cmTryCompileExec1752136972.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1752136972 -rdynamic -lc 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function dlopen exists in the dl passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3984572684/fast"
gmake -f CMakeFiles/cmTryCompileExec3984572684.dir/build.make CMakeFiles/cmTryCompileExec3984572684.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3984572684.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=dlopen   -o CMakeFiles/cmTryCompileExec3984572684.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3984572684
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3984572684.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=dlopen    CMakeFiles/cmTryCompileExec3984572684.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3984572684 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file features.h exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3005822117/fast"
gmake -f CMakeFiles/cmTryCompileExec3005822117.dir/build.make CMakeFiles/cmTryCompileExec3005822117.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3005822117.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3005822117.dir/CheckIncludeFile.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3005822117
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3005822117.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3005822117.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3005822117 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files ;stdio.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3455328616/fast"
gmake -f CMakeFiles/cmTryCompileExec3455328616.dir/build.make CMakeFiles/cmTryCompileExec3455328616.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3455328616.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3455328616.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3455328616
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3455328616.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3455328616.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3455328616 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2077542215/fast"
gmake -f CMakeFiles/cmTryCompileExec2077542215.dir/build.make CMakeFiles/cmTryCompileExec2077542215.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2077542215.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2077542215.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2077542215
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2077542215.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2077542215.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2077542215 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3710070945/fast"
gmake -f CMakeFiles/cmTryCompileExec3710070945.dir/build.make CMakeFiles/cmTryCompileExec3710070945.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3710070945.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3710070945.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3710070945
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3710070945.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3710070945.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3710070945 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2374254565/fast"
gmake -f CMakeFiles/cmTryCompileExec2374254565.dir/build.make CMakeFiles/cmTryCompileExec2374254565.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2374254565.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2374254565.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2374254565
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2374254565.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2374254565.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2374254565 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3837092461/fast"
gmake -f CMakeFiles/cmTryCompileExec3837092461.dir/build.make CMakeFiles/cmTryCompileExec3837092461.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3837092461.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3837092461.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3837092461
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3837092461.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3837092461.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3837092461 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3565110569/fast"
gmake -f CMakeFiles/cmTryCompileExec3565110569.dir/build.make CMakeFiles/cmTryCompileExec3565110569.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3565110569.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3565110569.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3565110569
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3565110569.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3565110569.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3565110569 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3663750925/fast"
gmake -f CMakeFiles/cmTryCompileExec3663750925.dir/build.make CMakeFiles/cmTryCompileExec3663750925.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3663750925.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3663750925.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3663750925
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3663750925.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3663750925.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3663750925 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3064210713/fast"
gmake -f CMakeFiles/cmTryCompileExec3064210713.dir/build.make CMakeFiles/cmTryCompileExec3064210713.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3064210713.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3064210713.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3064210713
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3064210713.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3064210713.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3064210713 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1235899467/fast"
gmake -f CMakeFiles/cmTryCompileExec1235899467.dir/build.make CMakeFiles/cmTryCompileExec1235899467.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1235899467.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1235899467.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1235899467
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1235899467.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1235899467.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1235899467 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3273360153/fast"
gmake -f CMakeFiles/cmTryCompileExec3273360153.dir/build.make CMakeFiles/cmTryCompileExec3273360153.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3273360153.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3273360153.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3273360153
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3273360153.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3273360153.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3273360153 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1049071416/fast"
gmake -f CMakeFiles/cmTryCompileExec1049071416.dir/build.make CMakeFiles/cmTryCompileExec1049071416.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1049071416.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1049071416.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1049071416
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1049071416.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1049071416.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1049071416 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2962583177/fast"
gmake -f CMakeFiles/cmTryCompileExec2962583177.dir/build.make CMakeFiles/cmTryCompileExec2962583177.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2962583177.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2962583177.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2962583177
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2962583177.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2962583177.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2962583177 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4277234445/fast"
gmake -f CMakeFiles/cmTryCompileExec4277234445.dir/build.make CMakeFiles/cmTryCompileExec4277234445.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4277234445.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4277234445.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4277234445
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4277234445.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4277234445.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4277234445 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1947283038/fast"
gmake -f CMakeFiles/cmTryCompileExec1947283038.dir/build.make CMakeFiles/cmTryCompileExec1947283038.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1947283038.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1947283038.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1947283038
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1947283038.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1947283038.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1947283038 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1937591472/fast"
gmake -f CMakeFiles/cmTryCompileExec1937591472.dir/build.make CMakeFiles/cmTryCompileExec1937591472.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1937591472.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1937591472.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1937591472
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1937591472.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1937591472.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1937591472 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1815663426/fast"
gmake -f CMakeFiles/cmTryCompileExec1815663426.dir/build.make CMakeFiles/cmTryCompileExec1815663426.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1815663426.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1815663426.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1815663426
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1815663426.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1815663426.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1815663426 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3213470165/fast"
gmake -f CMakeFiles/cmTryCompileExec3213470165.dir/build.make CMakeFiles/cmTryCompileExec3213470165.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3213470165.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3213470165.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3213470165
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3213470165.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3213470165.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3213470165 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3851522522/fast"
gmake -f CMakeFiles/cmTryCompileExec3851522522.dir/build.make CMakeFiles/cmTryCompileExec3851522522.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3851522522.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3851522522.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3851522522
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3851522522.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3851522522.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3851522522 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4049592194/fast"
gmake -f CMakeFiles/cmTryCompileExec4049592194.dir/build.make CMakeFiles/cmTryCompileExec4049592194.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4049592194.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4049592194.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4049592194
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4049592194.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4049592194.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4049592194 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3923453979/fast"
gmake -f CMakeFiles/cmTryCompileExec3923453979.dir/build.make CMakeFiles/cmTryCompileExec3923453979.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3923453979.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3923453979.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3923453979
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3923453979.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3923453979.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3923453979 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2137643250/fast"
gmake -f CMakeFiles/cmTryCompileExec2137643250.dir/build.make CMakeFiles/cmTryCompileExec2137643250.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2137643250.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2137643250.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2137643250
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2137643250.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2137643250.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2137643250 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec817659134/fast"
gmake -f CMakeFiles/cmTryCompileExec817659134.dir/build.make CMakeFiles/cmTryCompileExec817659134.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec817659134.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec817659134.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec817659134
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec817659134.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec817659134.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec817659134 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2698861506/fast"
gmake -f CMakeFiles/cmTryCompileExec2698861506.dir/build.make CMakeFiles/cmTryCompileExec2698861506.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2698861506.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2698861506.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2698861506
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2698861506.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2698861506.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2698861506 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1527398574/fast"
gmake -f CMakeFiles/cmTryCompileExec1527398574.dir/build.make CMakeFiles/cmTryCompileExec1527398574.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1527398574.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1527398574.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1527398574
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1527398574.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1527398574.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1527398574 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3590648167/fast"
gmake -f CMakeFiles/cmTryCompileExec3590648167.dir/build.make CMakeFiles/cmTryCompileExec3590648167.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3590648167.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3590648167.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3590648167
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3590648167.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3590648167.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3590648167 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1322879128/fast"
gmake -f CMakeFiles/cmTryCompileExec1322879128.dir/build.make CMakeFiles/cmTryCompileExec1322879128.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1322879128.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1322879128.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1322879128
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1322879128.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1322879128.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1322879128 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1796632305/fast"
gmake -f CMakeFiles/cmTryCompileExec1796632305.dir/build.make CMakeFiles/cmTryCompileExec1796632305.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1796632305.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1796632305.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1796632305
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1796632305.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1796632305.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1796632305 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3103885896/fast"
gmake -f CMakeFiles/cmTryCompileExec3103885896.dir/build.make CMakeFiles/cmTryCompileExec3103885896.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3103885896.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3103885896.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3103885896
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3103885896.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3103885896.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3103885896 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2152083011/fast"
gmake -f CMakeFiles/cmTryCompileExec2152083011.dir/build.make CMakeFiles/cmTryCompileExec2152083011.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2152083011.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2152083011.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2152083011
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2152083011.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2152083011.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2152083011 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3584782295/fast"
gmake -f CMakeFiles/cmTryCompileExec3584782295.dir/build.make CMakeFiles/cmTryCompileExec3584782295.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3584782295.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3584782295.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3584782295
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3584782295.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3584782295.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3584782295 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1907393120/fast"
gmake -f CMakeFiles/cmTryCompileExec1907393120.dir/build.make CMakeFiles/cmTryCompileExec1907393120.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1907393120.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1907393120.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1907393120
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1907393120.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1907393120.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1907393120 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2668571715/fast"
gmake -f CMakeFiles/cmTryCompileExec2668571715.dir/build.make CMakeFiles/cmTryCompileExec2668571715.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2668571715.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2668571715.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2668571715
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2668571715.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2668571715.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2668571715 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3749065580/fast"
gmake -f CMakeFiles/cmTryCompileExec3749065580.dir/build.make CMakeFiles/cmTryCompileExec3749065580.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3749065580.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3749065580.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3749065580
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3749065580.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3749065580.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3749065580 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2000500825/fast"
gmake -f CMakeFiles/cmTryCompileExec2000500825.dir/build.make CMakeFiles/cmTryCompileExec2000500825.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2000500825.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2000500825.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2000500825
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2000500825.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2000500825.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2000500825 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1491334821/fast"
gmake -f CMakeFiles/cmTryCompileExec1491334821.dir/build.make CMakeFiles/cmTryCompileExec1491334821.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1491334821.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1491334821.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1491334821
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1491334821.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1491334821.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1491334821 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1342424161/fast"
gmake -f CMakeFiles/cmTryCompileExec1342424161.dir/build.make CMakeFiles/cmTryCompileExec1342424161.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1342424161.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1342424161.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1342424161
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1342424161.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1342424161.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1342424161 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2702127486/fast"
gmake -f CMakeFiles/cmTryCompileExec2702127486.dir/build.make CMakeFiles/cmTryCompileExec2702127486.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2702127486.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2702127486.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2702127486
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2702127486.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2702127486.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2702127486 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3504810281/fast"
gmake -f CMakeFiles/cmTryCompileExec3504810281.dir/build.make CMakeFiles/cmTryCompileExec3504810281.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3504810281.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3504810281.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3504810281
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3504810281.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3504810281.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3504810281 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2713506384/fast"
gmake -f CMakeFiles/cmTryCompileExec2713506384.dir/build.make CMakeFiles/cmTryCompileExec2713506384.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2713506384.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2713506384.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2713506384
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2713506384.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2713506384.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2713506384 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h;libgen.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2081976381/fast"
gmake -f CMakeFiles/cmTryCompileExec2081976381.dir/build.make CMakeFiles/cmTryCompileExec2081976381.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2081976381.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2081976381.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2081976381
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2081976381.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2081976381.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2081976381 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec132209063/fast"
gmake -f CMakeFiles/cmTryCompileExec132209063.dir/build.make CMakeFiles/cmTryCompileExec132209063.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec132209063.dir/SIZEOF_SIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec132209063.dir/SIZEOF_SIZE_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_SIZE_T.c
Linking C executable cmTryCompileExec132209063
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec132209063.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec132209063.dir/SIZEOF_SIZE_T.c.o  -o cmTryCompileExec132209063 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1910104243/fast"
gmake -f CMakeFiles/cmTryCompileExec1910104243.dir/build.make CMakeFiles/cmTryCompileExec1910104243.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1910104243.dir/SIZEOF_SSIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1910104243.dir/SIZEOF_SSIZE_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_SSIZE_T.c
Linking C executable cmTryCompileExec1910104243
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1910104243.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1910104243.dir/SIZEOF_SSIZE_T.c.o  -o cmTryCompileExec1910104243 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3890460257/fast"
gmake -f CMakeFiles/cmTryCompileExec3890460257.dir/build.make CMakeFiles/cmTryCompileExec3890460257.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3890460257.dir/SIZEOF_LONG_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3890460257.dir/SIZEOF_LONG_LONG.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG_LONG.c
Linking C executable cmTryCompileExec3890460257
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3890460257.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3890460257.dir/SIZEOF_LONG_LONG.c.o  -o cmTryCompileExec3890460257 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1737886992/fast"
gmake -f CMakeFiles/cmTryCompileExec1737886992.dir/build.make CMakeFiles/cmTryCompileExec1737886992.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1737886992.dir/SIZEOF_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1737886992.dir/SIZEOF_LONG.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG.c
Linking C executable cmTryCompileExec1737886992
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1737886992.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1737886992.dir/SIZEOF_LONG.c.o  -o cmTryCompileExec1737886992 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of time_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec623228627/fast"
gmake -f CMakeFiles/cmTryCompileExec623228627.dir/build.make CMakeFiles/cmTryCompileExec623228627.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec623228627.dir/SIZEOF_TIME_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec623228627.dir/SIZEOF_TIME_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_TIME_T.c
Linking C executable cmTryCompileExec623228627
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec623228627.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec623228627.dir/SIZEOF_TIME_T.c.o  -o cmTryCompileExec623228627 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the basename exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1783489874/fast"
gmake -f CMakeFiles/cmTryCompileExec1783489874.dir/build.make CMakeFiles/cmTryCompileExec1783489874.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1783489874.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1783489874.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1783489874
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1783489874.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1783489874.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1783489874 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef basename
  return ((int*)(&basename))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the socket exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1365314421/fast"
gmake -f CMakeFiles/cmTryCompileExec1365314421.dir/build.make CMakeFiles/cmTryCompileExec1365314421.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1365314421.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1365314421.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1365314421
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1365314421.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1365314421.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1365314421 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef socket
  return ((int*)(&socket))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the poll exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2343870546/fast"
gmake -f CMakeFiles/cmTryCompileExec2343870546.dir/build.make CMakeFiles/cmTryCompileExec2343870546.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2343870546.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2343870546.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2343870546
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2343870546.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2343870546.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2343870546 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef poll
  return ((int*)(&poll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the select exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1705629059/fast"
gmake -f CMakeFiles/cmTryCompileExec1705629059.dir/build.make CMakeFiles/cmTryCompileExec1705629059.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1705629059.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1705629059.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1705629059
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1705629059.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1705629059.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1705629059 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef select
  return ((int*)(&select))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strdup exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3225644553/fast"
gmake -f CMakeFiles/cmTryCompileExec3225644553.dir/build.make CMakeFiles/cmTryCompileExec3225644553.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3225644553.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3225644553.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3225644553
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3225644553.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3225644553.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3225644553 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strdup
  return ((int*)(&strdup))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strstr exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3898215425/fast"
gmake -f CMakeFiles/cmTryCompileExec3898215425.dir/build.make CMakeFiles/cmTryCompileExec3898215425.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3898215425.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3898215425.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3898215425
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3898215425.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3898215425.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3898215425 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strstr
  return ((int*)(&strstr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtok_r exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4142478154/fast"
gmake -f CMakeFiles/cmTryCompileExec4142478154.dir/build.make CMakeFiles/cmTryCompileExec4142478154.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4142478154.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4142478154.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4142478154
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4142478154.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4142478154.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4142478154 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtok_r
  return ((int*)(&strtok_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strftime exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2219687077/fast"
gmake -f CMakeFiles/cmTryCompileExec2219687077.dir/build.make CMakeFiles/cmTryCompileExec2219687077.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2219687077.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2219687077.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2219687077
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2219687077.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2219687077.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2219687077 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strftime
  return ((int*)(&strftime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the uname exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3283242215/fast"
gmake -f CMakeFiles/cmTryCompileExec3283242215.dir/build.make CMakeFiles/cmTryCompileExec3283242215.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3283242215.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3283242215.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3283242215
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3283242215.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3283242215.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3283242215 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef uname
  return ((int*)(&uname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strcasecmp exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec328463150/fast"
gmake -f CMakeFiles/cmTryCompileExec328463150.dir/build.make CMakeFiles/cmTryCompileExec328463150.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec328463150.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec328463150.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec328463150
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec328463150.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec328463150.dir/CheckSymbolExists.c.o  -o cmTryCompileExec328463150 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strcasecmp
  return ((int*)(&strcasecmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2848139618/fast"
gmake -f CMakeFiles/cmTryCompileExec2848139618.dir/build.make CMakeFiles/cmTryCompileExec2848139618.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2848139618.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2848139618.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2848139618
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2848139618.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2848139618.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2848139618 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr
  return ((int*)(&gethostbyaddr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gettimeofday exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3884010652/fast"
gmake -f CMakeFiles/cmTryCompileExec3884010652.dir/build.make CMakeFiles/cmTryCompileExec3884010652.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3884010652.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3884010652.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3884010652
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3884010652.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3884010652.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3884010652 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gettimeofday
  return ((int*)(&gettimeofday))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_addr exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3634784048/fast"
gmake -f CMakeFiles/cmTryCompileExec3634784048.dir/build.make CMakeFiles/cmTryCompileExec3634784048.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3634784048.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3634784048.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3634784048
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3634784048.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3634784048.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3634784048 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_addr
  return ((int*)(&inet_addr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_pton exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2958878655/fast"
gmake -f CMakeFiles/cmTryCompileExec2958878655.dir/build.make CMakeFiles/cmTryCompileExec2958878655.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2958878655.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2958878655.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2958878655
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2958878655.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2958878655.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2958878655 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_pton
  return ((int*)(&inet_pton))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_ntoa exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3331968920/fast"
gmake -f CMakeFiles/cmTryCompileExec3331968920.dir/build.make CMakeFiles/cmTryCompileExec3331968920.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3331968920.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3331968920.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3331968920
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3331968920.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3331968920.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3331968920 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_ntoa
  return ((int*)(&inet_ntoa))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcsetattr exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2138244818/fast"
gmake -f CMakeFiles/cmTryCompileExec2138244818.dir/build.make CMakeFiles/cmTryCompileExec2138244818.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2138244818.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2138244818.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2138244818
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2138244818.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2138244818.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2138244818 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcsetattr
  return ((int*)(&tcsetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcgetattr exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec663095037/fast"
gmake -f CMakeFiles/cmTryCompileExec663095037.dir/build.make CMakeFiles/cmTryCompileExec663095037.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec663095037.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec663095037.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec663095037
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec663095037.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec663095037.dir/CheckSymbolExists.c.o  -o cmTryCompileExec663095037 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcgetattr
  return ((int*)(&tcgetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the perror exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4134745129/fast"
gmake -f CMakeFiles/cmTryCompileExec4134745129.dir/build.make CMakeFiles/cmTryCompileExec4134745129.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4134745129.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4134745129.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4134745129
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4134745129.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4134745129.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4134745129 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef perror
  return ((int*)(&perror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setvbuf exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3042594822/fast"
gmake -f CMakeFiles/cmTryCompileExec3042594822.dir/build.make CMakeFiles/cmTryCompileExec3042594822.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3042594822.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3042594822.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3042594822
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3042594822.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3042594822.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3042594822 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setvbuf
  return ((int*)(&setvbuf))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigsetjmp exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2980534534/fast"
gmake -f CMakeFiles/cmTryCompileExec2980534534.dir/build.make CMakeFiles/cmTryCompileExec2980534534.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2980534534.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2980534534.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2980534534
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2980534534.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2980534534.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2980534534 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigsetjmp
  return ((int*)(&sigsetjmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getpwuid exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2821964186/fast"
gmake -f CMakeFiles/cmTryCompileExec2821964186.dir/build.make CMakeFiles/cmTryCompileExec2821964186.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2821964186.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2821964186.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2821964186
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2821964186.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2821964186.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2821964186 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getpwuid
  return ((int*)(&getpwuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the geteuid exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4003706169/fast"
gmake -f CMakeFiles/cmTryCompileExec4003706169.dir/build.make CMakeFiles/cmTryCompileExec4003706169.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4003706169.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4003706169.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4003706169
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4003706169.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4003706169.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4003706169 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef geteuid
  return ((int*)(&geteuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the utime exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2720230896/fast"
gmake -f CMakeFiles/cmTryCompileExec2720230896.dir/build.make CMakeFiles/cmTryCompileExec2720230896.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2720230896.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2720230896.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2720230896
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2720230896.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2720230896.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2720230896 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef utime
  return ((int*)(&utime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gmtime_r exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec55732847/fast"
gmake -f CMakeFiles/cmTryCompileExec55732847.dir/build.make CMakeFiles/cmTryCompileExec55732847.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec55732847.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec55732847.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec55732847
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec55732847.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec55732847.dir/CheckSymbolExists.c.o  -o cmTryCompileExec55732847 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gmtime_r
  return ((int*)(&gmtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the localtime_r exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1173557902/fast"
gmake -f CMakeFiles/cmTryCompileExec1173557902.dir/build.make CMakeFiles/cmTryCompileExec1173557902.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1173557902.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1173557902.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1173557902
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1173557902.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1173557902.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1173557902 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef localtime_r
  return ((int*)(&localtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2726416278/fast"
gmake -f CMakeFiles/cmTryCompileExec2726416278.dir/build.make CMakeFiles/cmTryCompileExec2726416278.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2726416278.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2726416278.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2726416278
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2726416278.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2726416278.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2726416278 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname
  return ((int*)(&gethostbyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname_r exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3934708893/fast"
gmake -f CMakeFiles/cmTryCompileExec3934708893.dir/build.make CMakeFiles/cmTryCompileExec3934708893.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3934708893.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3934708893.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3934708893
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3934708893.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3934708893.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3934708893 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname_r
  return ((int*)(&gethostbyname_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr_r exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1917136202/fast"
gmake -f CMakeFiles/cmTryCompileExec1917136202.dir/build.make CMakeFiles/cmTryCompileExec1917136202.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1917136202.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1917136202.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1917136202
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1917136202.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1917136202.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1917136202 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr_r
  return ((int*)(&gethostbyaddr_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the signal exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec596523037/fast"
gmake -f CMakeFiles/cmTryCompileExec596523037.dir/build.make CMakeFiles/cmTryCompileExec596523037.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec596523037.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec596523037.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec596523037
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec596523037.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec596523037.dir/CheckSymbolExists.c.o  -o cmTryCompileExec596523037 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef signal
  return ((int*)(&signal))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIGALRM exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3502655628/fast"
gmake -f CMakeFiles/cmTryCompileExec3502655628.dir/build.make CMakeFiles/cmTryCompileExec3502655628.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3502655628.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3502655628.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3502655628
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3502655628.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3502655628.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3502655628 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIGALRM
  return ((int*)(&SIGALRM))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtoll exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3798479764/fast"
gmake -f CMakeFiles/cmTryCompileExec3798479764.dir/build.make CMakeFiles/cmTryCompileExec3798479764.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3798479764.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3798479764.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3798479764
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3798479764.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3798479764.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3798479764 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtoll
  return ((int*)(&strtoll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strerror_r exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2678491846/fast"
gmake -f CMakeFiles/cmTryCompileExec2678491846.dir/build.make CMakeFiles/cmTryCompileExec2678491846.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2678491846.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2678491846.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2678491846
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2678491846.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2678491846.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2678491846 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strerror_r
  return ((int*)(&strerror_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the siginterrupt exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1512373703/fast"
gmake -f CMakeFiles/cmTryCompileExec1512373703.dir/build.make CMakeFiles/cmTryCompileExec1512373703.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1512373703.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1512373703.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1512373703
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1512373703.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1512373703.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1512373703 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef siginterrupt
  return ((int*)(&siginterrupt))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the fork exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3259639820/fast"
gmake -f CMakeFiles/cmTryCompileExec3259639820.dir/build.make CMakeFiles/cmTryCompileExec3259639820.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3259639820.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3259639820.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3259639820
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3259639820.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3259639820.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3259639820 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef fork
  return ((int*)(&fork))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the pipe exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec329137793/fast"
gmake -f CMakeFiles/cmTryCompileExec329137793.dir/build.make CMakeFiles/cmTryCompileExec329137793.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec329137793.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec329137793.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec329137793
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec329137793.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec329137793.dir/CheckSymbolExists.c.o  -o cmTryCompileExec329137793 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef pipe
  return ((int*)(&pipe))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the ftruncate exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2151282225/fast"
gmake -f CMakeFiles/cmTryCompileExec2151282225.dir/build.make CMakeFiles/cmTryCompileExec2151282225.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2151282225.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2151282225.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2151282225
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2151282225.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2151282225.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2151282225 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef ftruncate
  return ((int*)(&ftruncate))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getprotobyname exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec171610937/fast"
gmake -f CMakeFiles/cmTryCompileExec171610937.dir/build.make CMakeFiles/cmTryCompileExec171610937.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec171610937.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec171610937.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec171610937
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec171610937.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec171610937.dir/CheckSymbolExists.c.o  -o cmTryCompileExec171610937 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getprotobyname
  return ((int*)(&getprotobyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getrlimit exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec31588929/fast"
gmake -f CMakeFiles/cmTryCompileExec31588929.dir/build.make CMakeFiles/cmTryCompileExec31588929.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec31588929.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec31588929.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec31588929
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec31588929.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec31588929.dir/CheckSymbolExists.c.o  -o cmTryCompileExec31588929 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getrlimit
  return ((int*)(&getrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setlocale exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2059287423/fast"
gmake -f CMakeFiles/cmTryCompileExec2059287423.dir/build.make CMakeFiles/cmTryCompileExec2059287423.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2059287423.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2059287423.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2059287423
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2059287423.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2059287423.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2059287423 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setlocale
  return ((int*)(&setlocale))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setrlimit exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3852431981/fast"
gmake -f CMakeFiles/cmTryCompileExec3852431981.dir/build.make CMakeFiles/cmTryCompileExec3852431981.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3852431981.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3852431981.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3852431981
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3852431981.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3852431981.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3852431981 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setrlimit
  return ((int*)(&setrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigaction exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1222994926/fast"
gmake -f CMakeFiles/cmTryCompileExec1222994926.dir/build.make CMakeFiles/cmTryCompileExec1222994926.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1222994926.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1222994926.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1222994926
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1222994926.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1222994926.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1222994926 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <signal.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigaction
  return ((int*)(&sigaction))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing Curl Test HAVE_O_NONBLOCK passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2662757585/fast"
gmake -f CMakeFiles/cmTryCompileExec2662757585.dir/build.make CMakeFiles/cmTryCompileExec2662757585.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2662757585.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_O_NONBLOCK   -o CMakeFiles/cmTryCompileExec2662757585.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2662757585
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2662757585.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_O_NONBLOCK    CMakeFiles/cmTryCompileExec2662757585.dir/CurlTests.c.o  -o cmTryCompileExec2662757585 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test TIME_WITH_SYS_TIME passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4244188899/fast"
gmake -f CMakeFiles/cmTryCompileExec4244188899.dir/build.make CMakeFiles/cmTryCompileExec4244188899.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4244188899.dir/CurlTests.c.o
/usr/bin/gcc   -DTIME_WITH_SYS_TIME   -o CMakeFiles/cmTryCompileExec4244188899.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec4244188899
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4244188899.dir/link.txt --verbose=1
/usr/bin/gcc      -DTIME_WITH_SYS_TIME    CMakeFiles/cmTryCompileExec4244188899.dir/CurlTests.c.o  -o cmTryCompileExec4244188899 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8 passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3314914454/fast"
gmake -f CMakeFiles/cmTryCompileExec3314914454.dir/build.make CMakeFiles/cmTryCompileExec3314914454.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3314914454.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8   -o CMakeFiles/cmTryCompileExec3314914454.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3314914454
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3314914454.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8    CMakeFiles/cmTryCompileExec3314914454.dir/CurlTests.c.o  -o cmTryCompileExec3314914454 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8_REENTRANT passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1526087587/fast"
gmake -f CMakeFiles/cmTryCompileExec1526087587.dir/build.make CMakeFiles/cmTryCompileExec1526087587.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1526087587.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -o CMakeFiles/cmTryCompileExec1526087587.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1526087587
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1526087587.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8_REENTRANT    CMakeFiles/cmTryCompileExec1526087587.dir/CurlTests.c.o  -o cmTryCompileExec1526087587 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6 passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec73148096/fast"
gmake -f CMakeFiles/cmTryCompileExec73148096.dir/build.make CMakeFiles/cmTryCompileExec73148096.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec73148096.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6   -o CMakeFiles/cmTryCompileExec73148096.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec73148096
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec73148096.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6    CMakeFiles/cmTryCompileExec73148096.dir/CurlTests.c.o  -o cmTryCompileExec73148096 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6_REENTRANT passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec619791066/fast"
gmake -f CMakeFiles/cmTryCompileExec619791066.dir/build.make CMakeFiles/cmTryCompileExec619791066.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec619791066.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -o CMakeFiles/cmTryCompileExec619791066.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec619791066
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec619791066.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6_REENTRANT    CMakeFiles/cmTryCompileExec619791066.dir/CurlTests.c.o  -o cmTryCompileExec619791066 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_SOCKLEN_T passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1376107641/fast"
gmake -f CMakeFiles/cmTryCompileExec1376107641.dir/build.make CMakeFiles/cmTryCompileExec1376107641.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1376107641.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_SOCKLEN_T   -o CMakeFiles/cmTryCompileExec1376107641.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1376107641
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1376107641.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SOCKLEN_T    CMakeFiles/cmTryCompileExec1376107641.dir/CurlTests.c.o  -o cmTryCompileExec1376107641 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_IN_ADDR_T passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3031947880/fast"
gmake -f CMakeFiles/cmTryCompileExec3031947880.dir/build.make CMakeFiles/cmTryCompileExec3031947880.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3031947880.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_IN_ADDR_T   -o CMakeFiles/cmTryCompileExec3031947880.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3031947880
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3031947880.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_IN_ADDR_T    CMakeFiles/cmTryCompileExec3031947880.dir/CurlTests.c.o  -o cmTryCompileExec3031947880 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test STDC_HEADERS passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1953438818/fast"
gmake -f CMakeFiles/cmTryCompileExec1953438818.dir/build.make CMakeFiles/cmTryCompileExec1953438818.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1953438818.dir/CurlTests.c.o
/usr/bin/gcc   -DSTDC_HEADERS   -o CMakeFiles/cmTryCompileExec1953438818.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1953438818
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1953438818.dir/link.txt --verbose=1
/usr/bin/gcc      -DSTDC_HEADERS    CMakeFiles/cmTryCompileExec1953438818.dir/CurlTests.c.o  -o cmTryCompileExec1953438818 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test RETSIGTYPE_TEST passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec601709731/fast"
gmake -f CMakeFiles/cmTryCompileExec601709731.dir/build.make CMakeFiles/cmTryCompileExec601709731.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec601709731.dir/CurlTests.c.o
/usr/bin/gcc   -DRETSIGTYPE_TEST   -o CMakeFiles/cmTryCompileExec601709731.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec601709731
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec601709731.dir/link.txt --verbose=1
/usr/bin/gcc      -DRETSIGTYPE_TEST    CMakeFiles/cmTryCompileExec601709731.dir/CurlTests.c.o  -o cmTryCompileExec601709731 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETADDRINFO passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1159076203/fast"
gmake -f CMakeFiles/cmTryCompileExec1159076203.dir/build.make CMakeFiles/cmTryCompileExec1159076203.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1159076203.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETADDRINFO   -o CMakeFiles/cmTryCompileExec1159076203.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
/home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c:405: warning: incompatible implicit declaration of built-in function ‘memset’
Linking C executable cmTryCompileExec1159076203
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1159076203.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETADDRINFO    CMakeFiles/cmTryCompileExec1159076203.dir/CurlTests.c.o  -o cmTryCompileExec1159076203 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_FILE_OFFSET_BITS passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec587882511/fast"
gmake -f CMakeFiles/cmTryCompileExec587882511.dir/build.make CMakeFiles/cmTryCompileExec587882511.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec587882511.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_FILE_OFFSET_BITS   -o CMakeFiles/cmTryCompileExec587882511.dir/CurlTests.c.o   -c /home/lau/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec587882511
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec587882511.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_FILE_OFFSET_BITS    CMakeFiles/cmTryCompileExec587882511.dir/CurlTests.c.o  -o cmTryCompileExec587882511 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Determining size of curl_off_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec325075194/fast"
gmake -f CMakeFiles/cmTryCompileExec325075194.dir/build.make CMakeFiles/cmTryCompileExec325075194.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec325075194.dir/SIZEOF_CURL_OFF_T.c.o
/usr/bin/gcc   -D_FILE_OFFSET_BITS=64   -o CMakeFiles/cmTryCompileExec325075194.dir/SIZEOF_CURL_OFF_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_CURL_OFF_T.c
Linking C executable cmTryCompileExec325075194
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec325075194.dir/link.txt --verbose=1
/usr/bin/gcc      -D_FILE_OFFSET_BITS=64    CMakeFiles/cmTryCompileExec325075194.dir/SIZEOF_CURL_OFF_T.c.o  -o cmTryCompileExec325075194 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test curl_cv_recv succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3904176816/fast"
gmake -f CMakeFiles/cmTryCompileExec3904176816.dir/build.make CMakeFiles/cmTryCompileExec3904176816.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3904176816.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_recv   -o CMakeFiles/cmTryCompileExec3904176816.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3904176816
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3904176816.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_recv    CMakeFiles/cmTryCompileExec3904176816.dir/src.c.o  -o cmTryCompileExec3904176816 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>

#define __unused5 1

int main() { recv(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test int recv(int, void *, size_t, int) (curl_cv_func_recv_test) succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2883156181/fast"
gmake -f CMakeFiles/cmTryCompileExec2883156181.dir/build.make CMakeFiles/cmTryCompileExec2883156181.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2883156181.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_recv_test   -o CMakeFiles/cmTryCompileExec2883156181.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2883156181
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2883156181.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_recv_test    CMakeFiles/cmTryCompileExec2883156181.dir/src.c.o  -o cmTryCompileExec2883156181 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  recv(int, void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    void * buf=0;
                    size_t len=0;
                    int flags=0;
                    int res = recv(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test curl_cv_send succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1668178794/fast"
gmake -f CMakeFiles/cmTryCompileExec1668178794.dir/build.make CMakeFiles/cmTryCompileExec1668178794.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1668178794.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_send   -o CMakeFiles/cmTryCompileExec1668178794.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1668178794
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1668178794.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_send    CMakeFiles/cmTryCompileExec1668178794.dir/src.c.o  -o cmTryCompileExec1668178794 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  recv(int, void *, size_t, int);
#define __unused5 1

int main() { send(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test int send(int, const void *, size_t, int) (curl_cv_func_send_test) succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4053364975/fast"
gmake -f CMakeFiles/cmTryCompileExec4053364975.dir/build.make CMakeFiles/cmTryCompileExec4053364975.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4053364975.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_send_test   -o CMakeFiles/cmTryCompileExec4053364975.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec4053364975
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4053364975.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_send_test    CMakeFiles/cmTryCompileExec4053364975.dir/src.c.o  -o cmTryCompileExec4053364975 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  send(int, const void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    const void * buf=0;
                    size_t len=0;
                    int flags=0;
                    int res = send(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test HAVE_MSG_NOSIGNAL succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4074598052/fast"
gmake -f CMakeFiles/cmTryCompileExec4074598052.dir/build.make CMakeFiles/cmTryCompileExec4074598052.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4074598052.dir/src.c.o
/usr/bin/gcc   -DHAVE_MSG_NOSIGNAL   -o CMakeFiles/cmTryCompileExec4074598052.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c:12:1: warning: "__unused5" redefined
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c:8:1: warning: this is the location of the previous definition
Linking C executable cmTryCompileExec4074598052
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4074598052.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_MSG_NOSIGNAL    CMakeFiles/cmTryCompileExec4074598052.dir/src.c.o  -o cmTryCompileExec4074598052 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  send(int, const void *, size_t, int);
#define __unused5

#include <sys/types.h>
#include <sys/socket.h>
#define __unused5 1

int main() { int flag = MSG_NOSIGNAL ; return 0; }
Performing C SOURCE FILE Test HAVE_STRUCT_TIMEVAL succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2152287448/fast"
gmake -f CMakeFiles/cmTryCompileExec2152287448.dir/build.make CMakeFiles/cmTryCompileExec2152287448.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2152287448.dir/src.c.o
/usr/bin/gcc   -DHAVE_STRUCT_TIMEVAL   -o CMakeFiles/cmTryCompileExec2152287448.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2152287448
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2152287448.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_STRUCT_TIMEVAL    CMakeFiles/cmTryCompileExec2152287448.dir/src.c.o  -o cmTryCompileExec2152287448 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <time.h>
#define __unused5 1

int main() { struct timeval ts;
ts.tv_sec  = 0;
ts.tv_usec = 0 ; return 0; }
Determining size of sig_atomic_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec133451505/fast"
gmake -f CMakeFiles/cmTryCompileExec133451505.dir/build.make CMakeFiles/cmTryCompileExec133451505.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec133451505.dir/SIZEOF_SIG_ATOMIC_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec133451505.dir/SIZEOF_SIG_ATOMIC_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_SIG_ATOMIC_T.c
Linking C executable cmTryCompileExec133451505
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec133451505.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec133451505.dir/SIZEOF_SIG_ATOMIC_T.c.o  -o cmTryCompileExec133451505 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_SIG_ATOMIC_T_NOT_VOLATILE succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1479259009/fast"
gmake -f CMakeFiles/cmTryCompileExec1479259009.dir/build.make CMakeFiles/cmTryCompileExec1479259009.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1479259009.dir/src.c.o
/usr/bin/gcc   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -o CMakeFiles/cmTryCompileExec1479259009.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1479259009
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1479259009.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE    CMakeFiles/cmTryCompileExec1479259009.dir/src.c.o  -o cmTryCompileExec1479259009 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <signal.h>

int main() { static volatile sig_atomic_t dummy = 0 ; return 0; }
Determining size of struct sockaddr_storage passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3877450479/fast"
gmake -f CMakeFiles/cmTryCompileExec3877450479.dir/build.make CMakeFiles/cmTryCompileExec3877450479.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3877450479.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3877450479.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_STRUCT_SOCKADDR_STORAGE.c
Linking C executable cmTryCompileExec3877450479
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3877450479.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3877450479.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o  -o cmTryCompileExec3877450479 -rdynamic -ldl 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_DIRENT_H succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec605443206/fast"
gmake -f CMakeFiles/cmTryCompileExec605443206.dir/build.make CMakeFiles/cmTryCompileExec605443206.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec605443206.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_DIRENT_H   -o CMakeFiles/cmTryCompileExec605443206.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec605443206
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec605443206.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_DIRENT_H    CMakeFiles/cmTryCompileExec605443206.dir/src.c.o  -o cmTryCompileExec605443206 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <dirent.h>

int main()
{
   static DIR * tmp;
   if (sizeof(tmp))
      return 0;
  return 0;
}

Determining if files sys/types.h;ctype.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3011724773/fast"
gmake -f CMakeFiles/cmTryCompileExec3011724773.dir/build.make CMakeFiles/cmTryCompileExec3011724773.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3011724773.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3011724773.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3011724773
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3011724773.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3011724773.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3011724773 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1306543171/fast"
gmake -f CMakeFiles/cmTryCompileExec1306543171.dir/build.make CMakeFiles/cmTryCompileExec1306543171.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1306543171.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1306543171.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1306543171
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1306543171.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1306543171.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1306543171 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1415003658/fast"
gmake -f CMakeFiles/cmTryCompileExec1415003658.dir/build.make CMakeFiles/cmTryCompileExec1415003658.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1415003658.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1415003658.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1415003658
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1415003658.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1415003658.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1415003658 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1543328700/fast"
gmake -f CMakeFiles/cmTryCompileExec1543328700.dir/build.make CMakeFiles/cmTryCompileExec1543328700.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1543328700.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1543328700.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1543328700
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1543328700.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1543328700.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1543328700 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2368658784/fast"
gmake -f CMakeFiles/cmTryCompileExec2368658784.dir/build.make CMakeFiles/cmTryCompileExec2368658784.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2368658784.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2368658784.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2368658784
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2368658784.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2368658784.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2368658784 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2548550585/fast"
gmake -f CMakeFiles/cmTryCompileExec2548550585.dir/build.make CMakeFiles/cmTryCompileExec2548550585.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2548550585.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2548550585.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2548550585
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2548550585.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2548550585.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2548550585 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3466105432/fast"
gmake -f CMakeFiles/cmTryCompileExec3466105432.dir/build.make CMakeFiles/cmTryCompileExec3466105432.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3466105432.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3466105432.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3466105432
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3466105432.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3466105432.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3466105432 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3006526887/fast"
gmake -f CMakeFiles/cmTryCompileExec3006526887.dir/build.make CMakeFiles/cmTryCompileExec3006526887.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3006526887.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3006526887.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3006526887
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3006526887.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3006526887.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3006526887 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4108656461/fast"
gmake -f CMakeFiles/cmTryCompileExec4108656461.dir/build.make CMakeFiles/cmTryCompileExec4108656461.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4108656461.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4108656461.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4108656461
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4108656461.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4108656461.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4108656461 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3522349851/fast"
gmake -f CMakeFiles/cmTryCompileExec3522349851.dir/build.make CMakeFiles/cmTryCompileExec3522349851.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3522349851.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3522349851.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3522349851
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3522349851.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3522349851.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3522349851 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2973743935/fast"
gmake -f CMakeFiles/cmTryCompileExec2973743935.dir/build.make CMakeFiles/cmTryCompileExec2973743935.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2973743935.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2973743935.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2973743935
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2973743935.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2973743935.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2973743935 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec362032330/fast"
gmake -f CMakeFiles/cmTryCompileExec362032330.dir/build.make CMakeFiles/cmTryCompileExec362032330.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec362032330.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec362032330.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec362032330
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec362032330.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec362032330.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec362032330 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3676204495/fast"
gmake -f CMakeFiles/cmTryCompileExec3676204495.dir/build.make CMakeFiles/cmTryCompileExec3676204495.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3676204495.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3676204495.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3676204495
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3676204495.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3676204495.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3676204495 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1190875156/fast"
gmake -f CMakeFiles/cmTryCompileExec1190875156.dir/build.make CMakeFiles/cmTryCompileExec1190875156.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1190875156.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1190875156.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1190875156
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1190875156.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1190875156.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1190875156 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3769179424/fast"
gmake -f CMakeFiles/cmTryCompileExec3769179424.dir/build.make CMakeFiles/cmTryCompileExec3769179424.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3769179424.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3769179424.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3769179424
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3769179424.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3769179424.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3769179424 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3397847351/fast"
gmake -f CMakeFiles/cmTryCompileExec3397847351.dir/build.make CMakeFiles/cmTryCompileExec3397847351.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3397847351.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3397847351.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3397847351
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3397847351.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3397847351.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3397847351 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3529586647/fast"
gmake -f CMakeFiles/cmTryCompileExec3529586647.dir/build.make CMakeFiles/cmTryCompileExec3529586647.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3529586647.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3529586647.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3529586647
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3529586647.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3529586647.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3529586647 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h;wctype.h exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2967768261/fast"
gmake -f CMakeFiles/cmTryCompileExec2967768261.dir/build.make CMakeFiles/cmTryCompileExec2967768261.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2967768261.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2967768261.dir/CheckIncludeFiles.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2967768261
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2967768261.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2967768261.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2967768261 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test SAFE_TO_DEFINE_EXTENSIONS succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec529808635/fast"
gmake -f CMakeFiles/cmTryCompileExec529808635.dir/build.make CMakeFiles/cmTryCompileExec529808635.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec529808635.dir/src.c.o
/usr/bin/gcc   -w  -DSAFE_TO_DEFINE_EXTENSIONS   -o CMakeFiles/cmTryCompileExec529808635.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec529808635
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec529808635.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DSAFE_TO_DEFINE_EXTENSIONS    CMakeFiles/cmTryCompileExec529808635.dir/src.c.o  -o cmTryCompileExec529808635 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __EXTENSIONS__ 1
   
   int main() { return 0;}
Determining if the function chown exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1929531174/fast"
gmake -f CMakeFiles/cmTryCompileExec1929531174.dir/build.make CMakeFiles/cmTryCompileExec1929531174.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1929531174.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin   -o CMakeFiles/cmTryCompileExec1929531174.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1929531174
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1929531174.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin    CMakeFiles/cmTryCompileExec1929531174.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1929531174 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function chroot exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3140922509/fast"
gmake -f CMakeFiles/cmTryCompileExec3140922509.dir/build.make CMakeFiles/cmTryCompileExec3140922509.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3140922509.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin   -o CMakeFiles/cmTryCompileExec3140922509.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3140922509
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3140922509.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin    CMakeFiles/cmTryCompileExec3140922509.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3140922509 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function ctime_r exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1660464889/fast"
gmake -f CMakeFiles/cmTryCompileExec1660464889.dir/build.make CMakeFiles/cmTryCompileExec1660464889.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1660464889.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec1660464889.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1660464889
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1660464889.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin    CMakeFiles/cmTryCompileExec1660464889.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1660464889 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fchdir exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2815392910/fast"
gmake -f CMakeFiles/cmTryCompileExec2815392910.dir/build.make CMakeFiles/cmTryCompileExec2815392910.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2815392910.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec2815392910.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2815392910
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2815392910.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin    CMakeFiles/cmTryCompileExec2815392910.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2815392910 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fchmod exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2623897225/fast"
gmake -f CMakeFiles/cmTryCompileExec2623897225.dir/build.make CMakeFiles/cmTryCompileExec2623897225.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2623897225.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin   -o CMakeFiles/cmTryCompileExec2623897225.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2623897225
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2623897225.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin    CMakeFiles/cmTryCompileExec2623897225.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2623897225 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fchown exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1784865034/fast"
gmake -f CMakeFiles/cmTryCompileExec1784865034.dir/build.make CMakeFiles/cmTryCompileExec1784865034.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1784865034.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec1784865034.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1784865034
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1784865034.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin    CMakeFiles/cmTryCompileExec1784865034.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1784865034 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fcntl exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3875761395/fast"
gmake -f CMakeFiles/cmTryCompileExec3875761395.dir/build.make CMakeFiles/cmTryCompileExec3875761395.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3875761395.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin   -o CMakeFiles/cmTryCompileExec3875761395.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3875761395
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3875761395.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin    CMakeFiles/cmTryCompileExec3875761395.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3875761395 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fdopendir exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec765854634/fast"
gmake -f CMakeFiles/cmTryCompileExec765854634.dir/build.make CMakeFiles/cmTryCompileExec765854634.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec765854634.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin   -o CMakeFiles/cmTryCompileExec765854634.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec765854634
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec765854634.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin    CMakeFiles/cmTryCompileExec765854634.dir/CheckFunctionExists.c.o  -o cmTryCompileExec765854634 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstat exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1992512888/fast"
gmake -f CMakeFiles/cmTryCompileExec1992512888.dir/build.make CMakeFiles/cmTryCompileExec1992512888.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1992512888.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1992512888.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1992512888
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1992512888.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin    CMakeFiles/cmTryCompileExec1992512888.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1992512888 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstatat exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3185248017/fast"
gmake -f CMakeFiles/cmTryCompileExec3185248017.dir/build.make CMakeFiles/cmTryCompileExec3185248017.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3185248017.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3185248017.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3185248017
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3185248017.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin    CMakeFiles/cmTryCompileExec3185248017.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3185248017 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstatfs exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3685736933/fast"
gmake -f CMakeFiles/cmTryCompileExec3685736933.dir/build.make CMakeFiles/cmTryCompileExec3685736933.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3685736933.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3685736933.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3685736933
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3685736933.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin    CMakeFiles/cmTryCompileExec3685736933.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3685736933 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstatvfs exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1745666018/fast"
gmake -f CMakeFiles/cmTryCompileExec1745666018.dir/build.make CMakeFiles/cmTryCompileExec1745666018.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1745666018.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1745666018.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1745666018
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1745666018.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin    CMakeFiles/cmTryCompileExec1745666018.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1745666018 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function futimens exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec103450833/fast"
gmake -f CMakeFiles/cmTryCompileExec103450833.dir/build.make CMakeFiles/cmTryCompileExec103450833.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec103450833.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin   -o CMakeFiles/cmTryCompileExec103450833.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec103450833
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec103450833.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin    CMakeFiles/cmTryCompileExec103450833.dir/CheckFunctionExists.c.o  -o cmTryCompileExec103450833 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function futimes exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3454165445/fast"
gmake -f CMakeFiles/cmTryCompileExec3454165445.dir/build.make CMakeFiles/cmTryCompileExec3454165445.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3454165445.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec3454165445.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3454165445
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3454165445.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin    CMakeFiles/cmTryCompileExec3454165445.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3454165445 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function futimesat exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2053706559/fast"
gmake -f CMakeFiles/cmTryCompileExec2053706559.dir/build.make CMakeFiles/cmTryCompileExec2053706559.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2053706559.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2053706559.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2053706559
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2053706559.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin    CMakeFiles/cmTryCompileExec2053706559.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2053706559 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getgrgid_r exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3155378643/fast"
gmake -f CMakeFiles/cmTryCompileExec3155378643.dir/build.make CMakeFiles/cmTryCompileExec3155378643.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3155378643.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3155378643.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3155378643
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3155378643.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin    CMakeFiles/cmTryCompileExec3155378643.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3155378643 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getgrnam_r exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2253591991/fast"
gmake -f CMakeFiles/cmTryCompileExec2253591991.dir/build.make CMakeFiles/cmTryCompileExec2253591991.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2253591991.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2253591991.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2253591991
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2253591991.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec2253591991.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2253591991 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getpwnam_r exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3137048272/fast"
gmake -f CMakeFiles/cmTryCompileExec3137048272.dir/build.make CMakeFiles/cmTryCompileExec3137048272.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3137048272.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3137048272.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3137048272
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3137048272.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec3137048272.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3137048272 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getpwuid_r exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2304510530/fast"
gmake -f CMakeFiles/cmTryCompileExec2304510530.dir/build.make CMakeFiles/cmTryCompileExec2304510530.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2304510530.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2304510530.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2304510530
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2304510530.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin    CMakeFiles/cmTryCompileExec2304510530.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2304510530 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getpid exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec6178049/fast"
gmake -f CMakeFiles/cmTryCompileExec6178049.dir/build.make CMakeFiles/cmTryCompileExec6178049.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec6178049.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin   -o CMakeFiles/cmTryCompileExec6178049.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec6178049
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec6178049.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin    CMakeFiles/cmTryCompileExec6178049.dir/CheckFunctionExists.c.o  -o cmTryCompileExec6178049 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function lchown exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2858104614/fast"
gmake -f CMakeFiles/cmTryCompileExec2858104614.dir/build.make CMakeFiles/cmTryCompileExec2858104614.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2858104614.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec2858104614.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2858104614
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2858104614.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin    CMakeFiles/cmTryCompileExec2858104614.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2858104614 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function link exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec190173043/fast"
gmake -f CMakeFiles/cmTryCompileExec190173043.dir/build.make CMakeFiles/cmTryCompileExec190173043.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec190173043.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin   -o CMakeFiles/cmTryCompileExec190173043.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec190173043
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec190173043.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin    CMakeFiles/cmTryCompileExec190173043.dir/CheckFunctionExists.c.o  -o cmTryCompileExec190173043 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function lstat exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1416491190/fast"
gmake -f CMakeFiles/cmTryCompileExec1416491190.dir/build.make CMakeFiles/cmTryCompileExec1416491190.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1416491190.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1416491190.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1416491190
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1416491190.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin    CMakeFiles/cmTryCompileExec1416491190.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1416491190 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function lutimes exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2144289723/fast"
gmake -f CMakeFiles/cmTryCompileExec2144289723.dir/build.make CMakeFiles/cmTryCompileExec2144289723.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2144289723.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec2144289723.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2144289723
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2144289723.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin    CMakeFiles/cmTryCompileExec2144289723.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2144289723 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mbrtowc exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1920921113/fast"
gmake -f CMakeFiles/cmTryCompileExec1920921113.dir/build.make CMakeFiles/cmTryCompileExec1920921113.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1920921113.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin   -o CMakeFiles/cmTryCompileExec1920921113.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1920921113
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1920921113.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin    CMakeFiles/cmTryCompileExec1920921113.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1920921113 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mbsnrtowcs exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4001542155/fast"
gmake -f CMakeFiles/cmTryCompileExec4001542155.dir/build.make CMakeFiles/cmTryCompileExec4001542155.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4001542155.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin   -o CMakeFiles/cmTryCompileExec4001542155.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4001542155
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4001542155.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin    CMakeFiles/cmTryCompileExec4001542155.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4001542155 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function memmove exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2563436770/fast"
gmake -f CMakeFiles/cmTryCompileExec2563436770.dir/build.make CMakeFiles/cmTryCompileExec2563436770.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2563436770.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin   -o CMakeFiles/cmTryCompileExec2563436770.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2563436770
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2563436770.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin    CMakeFiles/cmTryCompileExec2563436770.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2563436770 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mkdir exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec979246101/fast"
gmake -f CMakeFiles/cmTryCompileExec979246101.dir/build.make CMakeFiles/cmTryCompileExec979246101.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec979246101.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec979246101.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec979246101
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec979246101.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin    CMakeFiles/cmTryCompileExec979246101.dir/CheckFunctionExists.c.o  -o cmTryCompileExec979246101 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mkfifo exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2743355155/fast"
gmake -f CMakeFiles/cmTryCompileExec2743355155.dir/build.make CMakeFiles/cmTryCompileExec2743355155.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2743355155.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin   -o CMakeFiles/cmTryCompileExec2743355155.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2743355155
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2743355155.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin    CMakeFiles/cmTryCompileExec2743355155.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2743355155 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mknod exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3984314645/fast"
gmake -f CMakeFiles/cmTryCompileExec3984314645.dir/build.make CMakeFiles/cmTryCompileExec3984314645.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3984314645.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin   -o CMakeFiles/cmTryCompileExec3984314645.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3984314645
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3984314645.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin    CMakeFiles/cmTryCompileExec3984314645.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3984314645 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mkstemp exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3275490090/fast"
gmake -f CMakeFiles/cmTryCompileExec3275490090.dir/build.make CMakeFiles/cmTryCompileExec3275490090.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3275490090.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin   -o CMakeFiles/cmTryCompileExec3275490090.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3275490090
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3275490090.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin    CMakeFiles/cmTryCompileExec3275490090.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3275490090 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function nl_langinfo exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2061393749/fast"
gmake -f CMakeFiles/cmTryCompileExec2061393749.dir/build.make CMakeFiles/cmTryCompileExec2061393749.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2061393749.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin   -o CMakeFiles/cmTryCompileExec2061393749.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2061393749
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2061393749.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin    CMakeFiles/cmTryCompileExec2061393749.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2061393749 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function openat exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3682200473/fast"
gmake -f CMakeFiles/cmTryCompileExec3682200473.dir/build.make CMakeFiles/cmTryCompileExec3682200473.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3682200473.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3682200473.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3682200473
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3682200473.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin    CMakeFiles/cmTryCompileExec3682200473.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3682200473 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function readlink exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2406390509/fast"
gmake -f CMakeFiles/cmTryCompileExec2406390509.dir/build.make CMakeFiles/cmTryCompileExec2406390509.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2406390509.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec2406390509.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2406390509
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2406390509.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin    CMakeFiles/cmTryCompileExec2406390509.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2406390509 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function setenv exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec186506729/fast"
gmake -f CMakeFiles/cmTryCompileExec186506729.dir/build.make CMakeFiles/cmTryCompileExec186506729.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec186506729.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin   -o CMakeFiles/cmTryCompileExec186506729.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec186506729
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec186506729.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin    CMakeFiles/cmTryCompileExec186506729.dir/CheckFunctionExists.c.o  -o cmTryCompileExec186506729 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function statfs exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2724871791/fast"
gmake -f CMakeFiles/cmTryCompileExec2724871791.dir/build.make CMakeFiles/cmTryCompileExec2724871791.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2724871791.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2724871791.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2724871791
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2724871791.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin    CMakeFiles/cmTryCompileExec2724871791.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2724871791 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function statvfs exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2510327386/fast"
gmake -f CMakeFiles/cmTryCompileExec2510327386.dir/build.make CMakeFiles/cmTryCompileExec2510327386.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2510327386.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2510327386.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2510327386
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2510327386.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin    CMakeFiles/cmTryCompileExec2510327386.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2510327386 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function strchr exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2510536235/fast"
gmake -f CMakeFiles/cmTryCompileExec2510536235.dir/build.make CMakeFiles/cmTryCompileExec2510536235.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2510536235.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec2510536235.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2510536235
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2510536235.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin    CMakeFiles/cmTryCompileExec2510536235.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2510536235 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function strerror exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec41870772/fast"
gmake -f CMakeFiles/cmTryCompileExec41870772.dir/build.make CMakeFiles/cmTryCompileExec41870772.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec41870772.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin   -o CMakeFiles/cmTryCompileExec41870772.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec41870772
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec41870772.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin    CMakeFiles/cmTryCompileExec41870772.dir/CheckFunctionExists.c.o  -o cmTryCompileExec41870772 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function strrchr exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2482490182/fast"
gmake -f CMakeFiles/cmTryCompileExec2482490182.dir/build.make CMakeFiles/cmTryCompileExec2482490182.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2482490182.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec2482490182.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2482490182
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2482490182.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin    CMakeFiles/cmTryCompileExec2482490182.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2482490182 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function symlink exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2423275886/fast"
gmake -f CMakeFiles/cmTryCompileExec2423275886.dir/build.make CMakeFiles/cmTryCompileExec2423275886.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2423275886.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec2423275886.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2423275886
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2423275886.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin    CMakeFiles/cmTryCompileExec2423275886.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2423275886 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function timegm exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3055659187/fast"
gmake -f CMakeFiles/cmTryCompileExec3055659187.dir/build.make CMakeFiles/cmTryCompileExec3055659187.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3055659187.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin   -o CMakeFiles/cmTryCompileExec3055659187.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3055659187
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3055659187.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin    CMakeFiles/cmTryCompileExec3055659187.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3055659187 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function tzset exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2152379987/fast"
gmake -f CMakeFiles/cmTryCompileExec2152379987.dir/build.make CMakeFiles/cmTryCompileExec2152379987.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2152379987.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin   -o CMakeFiles/cmTryCompileExec2152379987.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2152379987
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2152379987.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin    CMakeFiles/cmTryCompileExec2152379987.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2152379987 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function utimes exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1850186073/fast"
gmake -f CMakeFiles/cmTryCompileExec1850186073.dir/build.make CMakeFiles/cmTryCompileExec1850186073.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1850186073.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec1850186073.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1850186073
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1850186073.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin    CMakeFiles/cmTryCompileExec1850186073.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1850186073 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function utimensat exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1324849699/fast"
gmake -f CMakeFiles/cmTryCompileExec1324849699.dir/build.make CMakeFiles/cmTryCompileExec1324849699.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1324849699.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1324849699.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1324849699
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1324849699.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin    CMakeFiles/cmTryCompileExec1324849699.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1324849699 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function vfork exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2388341798/fast"
gmake -f CMakeFiles/cmTryCompileExec2388341798.dir/build.make CMakeFiles/cmTryCompileExec2388341798.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2388341798.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin   -o CMakeFiles/cmTryCompileExec2388341798.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2388341798
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2388341798.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin    CMakeFiles/cmTryCompileExec2388341798.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2388341798 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcrtomb exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1552767144/fast"
gmake -f CMakeFiles/cmTryCompileExec1552767144.dir/build.make CMakeFiles/cmTryCompileExec1552767144.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1552767144.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec1552767144.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1552767144
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1552767144.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin    CMakeFiles/cmTryCompileExec1552767144.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1552767144 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcscmp exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3391906924/fast"
gmake -f CMakeFiles/cmTryCompileExec3391906924.dir/build.make CMakeFiles/cmTryCompileExec3391906924.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3391906924.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec3391906924.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3391906924
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3391906924.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin    CMakeFiles/cmTryCompileExec3391906924.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3391906924 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcscpy exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec225443162/fast"
gmake -f CMakeFiles/cmTryCompileExec225443162.dir/build.make CMakeFiles/cmTryCompileExec225443162.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec225443162.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec225443162.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec225443162
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec225443162.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin    CMakeFiles/cmTryCompileExec225443162.dir/CheckFunctionExists.c.o  -o cmTryCompileExec225443162 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcslen exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1134295783/fast"
gmake -f CMakeFiles/cmTryCompileExec1134295783.dir/build.make CMakeFiles/cmTryCompileExec1134295783.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1134295783.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin   -o CMakeFiles/cmTryCompileExec1134295783.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1134295783
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1134295783.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin    CMakeFiles/cmTryCompileExec1134295783.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1134295783 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcsnrtombs exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2070671181/fast"
gmake -f CMakeFiles/cmTryCompileExec2070671181.dir/build.make CMakeFiles/cmTryCompileExec2070671181.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2070671181.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2070671181.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2070671181
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2070671181.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin    CMakeFiles/cmTryCompileExec2070671181.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2070671181 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wctomb exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec631166129/fast"
gmake -f CMakeFiles/cmTryCompileExec631166129.dir/build.make CMakeFiles/cmTryCompileExec631166129.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec631166129.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec631166129.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec631166129
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec631166129.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin    CMakeFiles/cmTryCompileExec631166129.dir/CheckFunctionExists.c.o  -o cmTryCompileExec631166129 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fseeko exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2875560929/fast"
gmake -f CMakeFiles/cmTryCompileExec2875560929.dir/build.make CMakeFiles/cmTryCompileExec2875560929.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2875560929.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin   -o CMakeFiles/cmTryCompileExec2875560929.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2875560929
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2875560929.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin    CMakeFiles/cmTryCompileExec2875560929.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2875560929 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function vprintf exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1064117422/fast"
gmake -f CMakeFiles/cmTryCompileExec1064117422.dir/build.make CMakeFiles/cmTryCompileExec1064117422.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1064117422.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin   -o CMakeFiles/cmTryCompileExec1064117422.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1064117422
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1064117422.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin    CMakeFiles/cmTryCompileExec1064117422.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1064117422 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcmp exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3899265186/fast"
gmake -f CMakeFiles/cmTryCompileExec3899265186.dir/build.make CMakeFiles/cmTryCompileExec3899265186.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3899265186.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec3899265186.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3899265186
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3899265186.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin    CMakeFiles/cmTryCompileExec3899265186.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3899265186 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcpy exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1723921830/fast"
gmake -f CMakeFiles/cmTryCompileExec1723921830.dir/build.make CMakeFiles/cmTryCompileExec1723921830.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1723921830.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec1723921830.dir/CheckFunctionExists.c.o   -c /home/lau/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1723921830
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1723921830.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin    CMakeFiles/cmTryCompileExec1723921830.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1723921830 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_READDIR_R succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2728876999/fast"
gmake -f CMakeFiles/cmTryCompileExec2728876999.dir/build.make CMakeFiles/cmTryCompileExec2728876999.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2728876999.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READDIR_R   -o CMakeFiles/cmTryCompileExec2728876999.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2728876999
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2728876999.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READDIR_R    CMakeFiles/cmTryCompileExec2728876999.dir/src.c.o  -o cmTryCompileExec2728876999 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <dirent.h>
int main() {DIR *d = opendir("."); struct dirent e,*r; return readdir_r(d,&e,&r);}
Performing C SOURCE FILE Test HAVE_READLINKAT succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3472363693/fast"
gmake -f CMakeFiles/cmTryCompileExec3472363693.dir/build.make CMakeFiles/cmTryCompileExec3472363693.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3472363693.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READLINKAT   -o CMakeFiles/cmTryCompileExec3472363693.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3472363693
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3472363693.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READLINKAT    CMakeFiles/cmTryCompileExec3472363693.dir/src.c.o  -o cmTryCompileExec3472363693 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <fcntl.h>
#include <unistd.h>
int main() {char buf[10]; return readlinkat(AT_FDCWD, "", buf, 0);}
Performing C SOURCE FILE Test MAJOR_IN_SYSMACROS succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3527956497/fast"
gmake -f CMakeFiles/cmTryCompileExec3527956497.dir/build.make CMakeFiles/cmTryCompileExec3527956497.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3527956497.dir/src.c.o
/usr/bin/gcc   -w  -DMAJOR_IN_SYSMACROS   -o CMakeFiles/cmTryCompileExec3527956497.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3527956497
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3527956497.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DMAJOR_IN_SYSMACROS    CMakeFiles/cmTryCompileExec3527956497.dir/src.c.o  -o cmTryCompileExec3527956497 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <sys/sysmacros.h>
int main() { return major(256); }
Determining if the EILSEQ exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2419582779/fast"
gmake -f CMakeFiles/cmTryCompileExec2419582779.dir/build.make CMakeFiles/cmTryCompileExec2419582779.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2419582779.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2419582779.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2419582779
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2419582779.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2419582779.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2419582779 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <errno.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef EILSEQ
  return ((int*)(&EILSEQ))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MAX exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec993103343/fast"
gmake -f CMakeFiles/cmTryCompileExec993103343.dir/build.make CMakeFiles/cmTryCompileExec993103343.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec993103343.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec993103343.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec993103343
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec993103343.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec993103343.dir/CheckSymbolExists.c.o  -o cmTryCompileExec993103343 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MAX
  return ((int*)(&INT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MIN exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec184828968/fast"
gmake -f CMakeFiles/cmTryCompileExec184828968.dir/build.make CMakeFiles/cmTryCompileExec184828968.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec184828968.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec184828968.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec184828968
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec184828968.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec184828968.dir/CheckSymbolExists.c.o  -o cmTryCompileExec184828968 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MIN
  return ((int*)(&INT64_MIN))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT32_MAX exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1549979531/fast"
gmake -f CMakeFiles/cmTryCompileExec1549979531.dir/build.make CMakeFiles/cmTryCompileExec1549979531.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1549979531.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1549979531.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1549979531
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1549979531.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1549979531.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1549979531 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT32_MAX
  return ((int*)(&UINT32_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT64_MAX exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1592477767/fast"
gmake -f CMakeFiles/cmTryCompileExec1592477767.dir/build.make CMakeFiles/cmTryCompileExec1592477767.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1592477767.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1592477767.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1592477767
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1592477767.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1592477767.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1592477767 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT64_MAX
  return ((int*)(&UINT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIZE_MAX exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1162556077/fast"
gmake -f CMakeFiles/cmTryCompileExec1162556077.dir/build.make CMakeFiles/cmTryCompileExec1162556077.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1162556077.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1162556077.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1162556077
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1162556077.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1162556077.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1162556077 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIZE_MAX
  return ((int*)(&SIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SSIZE_MAX exist passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec418206960/fast"
gmake -f CMakeFiles/cmTryCompileExec418206960.dir/build.make CMakeFiles/cmTryCompileExec418206960.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec418206960.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec418206960.dir/CheckSymbolExists.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec418206960
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec418206960.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec418206960.dir/CheckSymbolExists.c.o  -o cmTryCompileExec418206960 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SSIZE_MAX
  return ((int*)(&SSIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing C SOURCE FILE Test HAVE_STRUCT_TM_TM_GMTOFF succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2660945163/fast"
gmake -f CMakeFiles/cmTryCompileExec2660945163.dir/build.make CMakeFiles/cmTryCompileExec2660945163.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2660945163.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_TM_TM_GMTOFF   -o CMakeFiles/cmTryCompileExec2660945163.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2660945163
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2660945163.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_TM_TM_GMTOFF    CMakeFiles/cmTryCompileExec2660945163.dir/src.c.o  -o cmTryCompileExec2660945163 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <time.h>

int main()
{
   static struct tm tmp;
   if (sizeof(tmp.tm_gmtoff))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec122273888/fast"
gmake -f CMakeFiles/cmTryCompileExec122273888.dir/build.make CMakeFiles/cmTryCompileExec122273888.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec122273888.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -o CMakeFiles/cmTryCompileExec122273888.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec122273888
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec122273888.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC    CMakeFiles/cmTryCompileExec122273888.dir/src.c.o  -o cmTryCompileExec122273888 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_mtim.tv_nsec))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_BLKSIZE succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2192060270/fast"
gmake -f CMakeFiles/cmTryCompileExec2192060270.dir/build.make CMakeFiles/cmTryCompileExec2192060270.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2192060270.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE   -o CMakeFiles/cmTryCompileExec2192060270.dir/src.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2192060270
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2192060270.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE    CMakeFiles/cmTryCompileExec2192060270.dir/src.c.o  -o cmTryCompileExec2192060270 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_blksize))
      return 0;
  return 0;
}

Determining size of short passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec721206832/fast"
gmake -f CMakeFiles/cmTryCompileExec721206832.dir/build.make CMakeFiles/cmTryCompileExec721206832.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec721206832.dir/SIZE_OF_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec721206832.dir/SIZE_OF_SHORT.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_SHORT.c
Linking C executable cmTryCompileExec721206832
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec721206832.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec721206832.dir/SIZE_OF_SHORT.c.o  -o cmTryCompileExec721206832 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1944384983/fast"
gmake -f CMakeFiles/cmTryCompileExec1944384983.dir/build.make CMakeFiles/cmTryCompileExec1944384983.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1944384983.dir/SIZE_OF_INT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1944384983.dir/SIZE_OF_INT.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_INT.c
Linking C executable cmTryCompileExec1944384983
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1944384983.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1944384983.dir/SIZE_OF_INT.c.o  -o cmTryCompileExec1944384983 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec124992935/fast"
gmake -f CMakeFiles/cmTryCompileExec124992935.dir/build.make CMakeFiles/cmTryCompileExec124992935.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec124992935.dir/SIZE_OF_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec124992935.dir/SIZE_OF_LONG.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG.c
Linking C executable cmTryCompileExec124992935
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec124992935.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec124992935.dir/SIZE_OF_LONG.c.o  -o cmTryCompileExec124992935 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec939551793/fast"
gmake -f CMakeFiles/cmTryCompileExec939551793.dir/build.make CMakeFiles/cmTryCompileExec939551793.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec939551793.dir/SIZE_OF_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec939551793.dir/SIZE_OF_LONG_LONG.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG_LONG.c
Linking C executable cmTryCompileExec939551793
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec939551793.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec939551793.dir/SIZE_OF_LONG_LONG.c.o  -o cmTryCompileExec939551793 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned short passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4114316346/fast"
gmake -f CMakeFiles/cmTryCompileExec4114316346.dir/build.make CMakeFiles/cmTryCompileExec4114316346.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4114316346.dir/SIZE_OF_UNSIGNED_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4114316346.dir/SIZE_OF_UNSIGNED_SHORT.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec4114316346
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4114316346.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4114316346.dir/SIZE_OF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec4114316346 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1407373774/fast"
gmake -f CMakeFiles/cmTryCompileExec1407373774.dir/build.make CMakeFiles/cmTryCompileExec1407373774.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1407373774.dir/SIZE_OF_UNSIGNED.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1407373774.dir/SIZE_OF_UNSIGNED.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED.c
Linking C executable cmTryCompileExec1407373774
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1407373774.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1407373774.dir/SIZE_OF_UNSIGNED.c.o  -o cmTryCompileExec1407373774 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2550897089/fast"
gmake -f CMakeFiles/cmTryCompileExec2550897089.dir/build.make CMakeFiles/cmTryCompileExec2550897089.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2550897089.dir/SIZE_OF_UNSIGNED_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2550897089.dir/SIZE_OF_UNSIGNED_LONG.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG.c
Linking C executable cmTryCompileExec2550897089
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2550897089.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2550897089.dir/SIZE_OF_UNSIGNED_LONG.c.o  -o cmTryCompileExec2550897089 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long long passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1445712385/fast"
gmake -f CMakeFiles/cmTryCompileExec1445712385.dir/build.make CMakeFiles/cmTryCompileExec1445712385.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1445712385.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1445712385.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG_LONG.c
Linking C executable cmTryCompileExec1445712385
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1445712385.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1445712385.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o  -o cmTryCompileExec1445712385 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int16_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1370064899/fast"
gmake -f CMakeFiles/cmTryCompileExec1370064899.dir/build.make CMakeFiles/cmTryCompileExec1370064899.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1370064899.dir/INT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1370064899.dir/INT16_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INT16_T.c
Linking C executable cmTryCompileExec1370064899
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1370064899.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1370064899.dir/INT16_T.c.o  -o cmTryCompileExec1370064899 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int32_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4280391624/fast"
gmake -f CMakeFiles/cmTryCompileExec4280391624.dir/build.make CMakeFiles/cmTryCompileExec4280391624.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4280391624.dir/INT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4280391624.dir/INT32_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INT32_T.c
Linking C executable cmTryCompileExec4280391624
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4280391624.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4280391624.dir/INT32_T.c.o  -o cmTryCompileExec4280391624 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int64_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1468738396/fast"
gmake -f CMakeFiles/cmTryCompileExec1468738396.dir/build.make CMakeFiles/cmTryCompileExec1468738396.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1468738396.dir/INT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1468738396.dir/INT64_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INT64_T.c
Linking C executable cmTryCompileExec1468738396
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1468738396.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1468738396.dir/INT64_T.c.o  -o cmTryCompileExec1468738396 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of intmax_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1304589836/fast"
gmake -f CMakeFiles/cmTryCompileExec1304589836.dir/build.make CMakeFiles/cmTryCompileExec1304589836.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1304589836.dir/INTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1304589836.dir/INTMAX_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INTMAX_T.c
Linking C executable cmTryCompileExec1304589836
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1304589836.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1304589836.dir/INTMAX_T.c.o  -o cmTryCompileExec1304589836 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint8_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1943980276/fast"
gmake -f CMakeFiles/cmTryCompileExec1943980276.dir/build.make CMakeFiles/cmTryCompileExec1943980276.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1943980276.dir/UINT8_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1943980276.dir/UINT8_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT8_T.c
Linking C executable cmTryCompileExec1943980276
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1943980276.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1943980276.dir/UINT8_T.c.o  -o cmTryCompileExec1943980276 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint16_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3783117745/fast"
gmake -f CMakeFiles/cmTryCompileExec3783117745.dir/build.make CMakeFiles/cmTryCompileExec3783117745.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3783117745.dir/UINT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3783117745.dir/UINT16_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT16_T.c
Linking C executable cmTryCompileExec3783117745
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3783117745.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3783117745.dir/UINT16_T.c.o  -o cmTryCompileExec3783117745 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint32_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2633219531/fast"
gmake -f CMakeFiles/cmTryCompileExec2633219531.dir/build.make CMakeFiles/cmTryCompileExec2633219531.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2633219531.dir/UINT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2633219531.dir/UINT32_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT32_T.c
Linking C executable cmTryCompileExec2633219531
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2633219531.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2633219531.dir/UINT32_T.c.o  -o cmTryCompileExec2633219531 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint64_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2728973148/fast"
gmake -f CMakeFiles/cmTryCompileExec2728973148.dir/build.make CMakeFiles/cmTryCompileExec2728973148.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2728973148.dir/UINT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2728973148.dir/UINT64_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT64_T.c
Linking C executable cmTryCompileExec2728973148
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2728973148.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2728973148.dir/UINT64_T.c.o  -o cmTryCompileExec2728973148 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uintmax_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3747151857/fast"
gmake -f CMakeFiles/cmTryCompileExec3747151857.dir/build.make CMakeFiles/cmTryCompileExec3747151857.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3747151857.dir/UINTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3747151857.dir/UINTMAX_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINTMAX_T.c
Linking C executable cmTryCompileExec3747151857
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3747151857.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3747151857.dir/UINTMAX_T.c.o  -o cmTryCompileExec3747151857 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of dev_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3239019543/fast"
gmake -f CMakeFiles/cmTryCompileExec3239019543.dir/build.make CMakeFiles/cmTryCompileExec3239019543.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3239019543.dir/DEV_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3239019543.dir/DEV_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/DEV_T.c
Linking C executable cmTryCompileExec3239019543
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3239019543.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3239019543.dir/DEV_T.c.o  -o cmTryCompileExec3239019543 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of gid_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1839862296/fast"
gmake -f CMakeFiles/cmTryCompileExec1839862296.dir/build.make CMakeFiles/cmTryCompileExec1839862296.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1839862296.dir/GID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1839862296.dir/GID_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/GID_T.c
Linking C executable cmTryCompileExec1839862296
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1839862296.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1839862296.dir/GID_T.c.o  -o cmTryCompileExec1839862296 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of id_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2389219033/fast"
gmake -f CMakeFiles/cmTryCompileExec2389219033.dir/build.make CMakeFiles/cmTryCompileExec2389219033.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2389219033.dir/ID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2389219033.dir/ID_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/ID_T.c
Linking C executable cmTryCompileExec2389219033
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2389219033.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2389219033.dir/ID_T.c.o  -o cmTryCompileExec2389219033 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of mode_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec167098919/fast"
gmake -f CMakeFiles/cmTryCompileExec167098919.dir/build.make CMakeFiles/cmTryCompileExec167098919.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec167098919.dir/MODE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec167098919.dir/MODE_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/MODE_T.c
Linking C executable cmTryCompileExec167098919
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec167098919.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec167098919.dir/MODE_T.c.o  -o cmTryCompileExec167098919 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of off_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2184683780/fast"
gmake -f CMakeFiles/cmTryCompileExec2184683780.dir/build.make CMakeFiles/cmTryCompileExec2184683780.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2184683780.dir/OFF_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2184683780.dir/OFF_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/OFF_T.c
Linking C executable cmTryCompileExec2184683780
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2184683780.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2184683780.dir/OFF_T.c.o  -o cmTryCompileExec2184683780 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3090275614/fast"
gmake -f CMakeFiles/cmTryCompileExec3090275614.dir/build.make CMakeFiles/cmTryCompileExec3090275614.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3090275614.dir/SIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3090275614.dir/SIZE_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_T.c
Linking C executable cmTryCompileExec3090275614
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3090275614.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3090275614.dir/SIZE_T.c.o  -o cmTryCompileExec3090275614 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1666733460/fast"
gmake -f CMakeFiles/cmTryCompileExec1666733460.dir/build.make CMakeFiles/cmTryCompileExec1666733460.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1666733460.dir/SSIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1666733460.dir/SSIZE_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SSIZE_T.c
Linking C executable cmTryCompileExec1666733460
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1666733460.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1666733460.dir/SSIZE_T.c.o  -o cmTryCompileExec1666733460 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uid_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3385291016/fast"
gmake -f CMakeFiles/cmTryCompileExec3385291016.dir/build.make CMakeFiles/cmTryCompileExec3385291016.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3385291016.dir/UID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3385291016.dir/UID_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UID_T.c
Linking C executable cmTryCompileExec3385291016
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3385291016.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3385291016.dir/UID_T.c.o  -o cmTryCompileExec3385291016 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of pid_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2997333097/fast"
gmake -f CMakeFiles/cmTryCompileExec2997333097.dir/build.make CMakeFiles/cmTryCompileExec2997333097.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2997333097.dir/PID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2997333097.dir/PID_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/PID_T.c
Linking C executable cmTryCompileExec2997333097
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2997333097.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2997333097.dir/PID_T.c.o  -o cmTryCompileExec2997333097 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of intptr_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec661134336/fast"
gmake -f CMakeFiles/cmTryCompileExec661134336.dir/build.make CMakeFiles/cmTryCompileExec661134336.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec661134336.dir/INTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec661134336.dir/INTPTR_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INTPTR_T.c
Linking C executable cmTryCompileExec661134336
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec661134336.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec661134336.dir/INTPTR_T.c.o  -o cmTryCompileExec661134336 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uintptr_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2228980167/fast"
gmake -f CMakeFiles/cmTryCompileExec2228980167.dir/build.make CMakeFiles/cmTryCompileExec2228980167.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2228980167.dir/UINTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2228980167.dir/UINTPTR_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINTPTR_T.c
Linking C executable cmTryCompileExec2228980167
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2228980167.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2228980167.dir/UINTPTR_T.c.o  -o cmTryCompileExec2228980167 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of wchar_t passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2555351861/fast"
gmake -f CMakeFiles/cmTryCompileExec2555351861.dir/build.make CMakeFiles/cmTryCompileExec2555351861.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2555351861.dir/SIZEOF_WCHAR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2555351861.dir/SIZEOF_WCHAR_T.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_WCHAR_T.c
Linking C executable cmTryCompileExec2555351861
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2555351861.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2555351861.dir/SIZEOF_WCHAR_T.c.o  -o cmTryCompileExec2555351861 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Checking support for ARCHIVE_CRYPTO_MD5_LIBC failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2995700796/fast"
gmake -f CMakeFiles/cmTryCompileExec2995700796.dir/build.make CMakeFiles/cmTryCompileExec2995700796.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2995700796.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2995700796.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:61:17: error: md5.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:156: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:117: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:124: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:132: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1237: error: ‘__archive_libc_md5init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1238: error: ‘__archive_libc_md5update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1239: error: ‘__archive_libc_md5final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec2995700796.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec2995700796/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBC failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec415953952/fast"
gmake -f CMakeFiles/cmTryCompileExec415953952.dir/build.make CMakeFiles/cmTryCompileExec415953952.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec415953952.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec415953952.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:64:20: error: rmd160.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:172: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_rmd160_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:357: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:358: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:293: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:300: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:308: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1268: error: ‘__archive_libc_ripemd160init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1269: error: ‘__archive_libc_ripemd160update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1270: error: ‘__archive_libc_ripemd160final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec415953952.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec415953952/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBC failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3106868018/fast"
gmake -f CMakeFiles/cmTryCompileExec3106868018.dir/build.make CMakeFiles/cmTryCompileExec3106868018.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3106868018.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3106868018.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:67:18: error: sha1.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:184: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:419: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:426: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:434: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1291: error: ‘__archive_libc_sha1init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1292: error: ‘__archive_libc_sha1update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1293: error: ‘__archive_libc_sha1final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec3106868018.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec3106868018/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec99564833/fast"
gmake -f CMakeFiles/cmTryCompileExec99564833.dir/build.make CMakeFiles/cmTryCompileExec99564833.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec99564833.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec99564833.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:200: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:595: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:602: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:610: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1322: error: ‘__archive_libc_sha256init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1323: error: ‘__archive_libc_sha256update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1324: error: ‘__archive_libc_sha256final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec99564833.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec99564833/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3693291285/fast"
gmake -f CMakeFiles/cmTryCompileExec3693291285.dir/build.make CMakeFiles/cmTryCompileExec3693291285.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3693291285.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3693291285.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:220: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:814: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:821: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:829: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1361: error: ‘__archive_libc_sha384init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1362: error: ‘__archive_libc_sha384update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1363: error: ‘__archive_libc_sha384final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec3693291285.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec3693291285/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec501112755/fast"
gmake -f CMakeFiles/cmTryCompileExec501112755.dir/build.make CMakeFiles/cmTryCompileExec501112755.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec501112755.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec501112755.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:238: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1009: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1016: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1024: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1396: error: ‘__archive_libc_sha512init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1397: error: ‘__archive_libc_sha512update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1398: error: ‘__archive_libc_sha512final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec501112755.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec501112755/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC2 failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3098279300/fast"
gmake -f CMakeFiles/cmTryCompileExec3098279300.dir/build.make CMakeFiles/cmTryCompileExec3098279300.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3098279300.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3098279300.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:202: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:619: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:626: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:634: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1326: error: ‘__archive_libc2_sha256init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1327: error: ‘__archive_libc2_sha256update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1328: error: ‘__archive_libc2_sha256final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec3098279300.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec3098279300/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC2 failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec653268502/fast"
gmake -f CMakeFiles/cmTryCompileExec653268502.dir/build.make CMakeFiles/cmTryCompileExec653268502.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec653268502.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec653268502.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:222: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:838: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:845: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:853: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1365: error: ‘__archive_libc2_sha384init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1366: error: ‘__archive_libc2_sha384update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1367: error: ‘__archive_libc2_sha384final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec653268502.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec653268502/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC2 failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3725843689/fast"
gmake -f CMakeFiles/cmTryCompileExec3725843689.dir/build.make CMakeFiles/cmTryCompileExec3725843689.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3725843689.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3725843689.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:240: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1033: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1040: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1048: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1400: error: ‘__archive_libc2_sha512init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1401: error: ‘__archive_libc2_sha512update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1402: error: ‘__archive_libc2_sha512final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec3725843689.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec3725843689/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC3 failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec296841055/fast"
gmake -f CMakeFiles/cmTryCompileExec296841055.dir/build.make CMakeFiles/cmTryCompileExec296841055.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec296841055.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec296841055.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:204: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:643: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:650: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:658: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1330: error: ‘__archive_libc3_sha256init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1331: error: ‘__archive_libc3_sha256update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1332: error: ‘__archive_libc3_sha256final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec296841055.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec296841055/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC3 failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3673532559/fast"
gmake -f CMakeFiles/cmTryCompileExec3673532559.dir/build.make CMakeFiles/cmTryCompileExec3673532559.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3673532559.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3673532559.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:224: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:862: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:869: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:877: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1369: error: ‘__archive_libc3_sha384init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1370: error: ‘__archive_libc3_sha384update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1371: error: ‘__archive_libc3_sha384final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec3673532559.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec3673532559/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC3 failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1780124790/fast"
gmake -f CMakeFiles/cmTryCompileExec1780124790.dir/build.make CMakeFiles/cmTryCompileExec1780124790.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1780124790.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1780124790.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:242: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1057: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1064: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1072: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1404: error: ‘__archive_libc3_sha512init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1405: error: ‘__archive_libc3_sha512update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1406: error: ‘__archive_libc3_sha512final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec1780124790.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec1780124790/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec275109169/fast"
gmake -f CMakeFiles/cmTryCompileExec275109169.dir/build.make CMakeFiles/cmTryCompileExec275109169.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec275109169.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec275109169.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:160: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:165: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:172: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:180: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1245: error: ‘__archive_libsystem_md5init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1246: error: ‘__archive_libsystem_md5update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1247: error: ‘__archive_libsystem_md5final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec275109169.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec275109169/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2442023179/fast"
gmake -f CMakeFiles/cmTryCompileExec2442023179.dir/build.make CMakeFiles/cmTryCompileExec2442023179.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2442023179.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2442023179.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:188: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:467: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:474: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:482: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1299: error: ‘__archive_libsystem_sha1init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1300: error: ‘__archive_libsystem_sha1update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1301: error: ‘__archive_libsystem_sha1final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec2442023179.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec2442023179/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3576780297/fast"
gmake -f CMakeFiles/cmTryCompileExec3576780297.dir/build.make CMakeFiles/cmTryCompileExec3576780297.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3576780297.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3576780297.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:208: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:691: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:698: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:706: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1338: error: ‘__archive_libsystem_sha256init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1339: error: ‘__archive_libsystem_sha256update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1340: error: ‘__archive_libsystem_sha256final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec3576780297.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec3576780297/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec501591651/fast"
gmake -f CMakeFiles/cmTryCompileExec501591651.dir/build.make CMakeFiles/cmTryCompileExec501591651.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec501591651.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec501591651.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:226: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:886: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:893: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:901: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1373: error: ‘__archive_libsystem_sha384init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1374: error: ‘__archive_libsystem_sha384update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1375: error: ‘__archive_libsystem_sha384final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec501591651.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec501591651/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec892660897/fast"
gmake -f CMakeFiles/cmTryCompileExec892660897.dir/build.make CMakeFiles/cmTryCompileExec892660897.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec892660897.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec892660897.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:246: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1105: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1112: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1120: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1412: error: ‘__archive_libsystem_sha512init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1413: error: ‘__archive_libsystem_sha512update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1414: error: ‘__archive_libsystem_sha512final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec892660897.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec892660897/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBMD failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1045198093/fast"
gmake -f CMakeFiles/cmTryCompileExec1045198093.dir/build.make CMakeFiles/cmTryCompileExec1045198093.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1045198093.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1045198093.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:91:17: error: md5.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:158: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:141: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:148: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:156: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1241: error: ‘__archive_libmd_md5init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1242: error: ‘__archive_libmd_md5update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1243: error: ‘__archive_libmd_md5final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec1045198093.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec1045198093/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBMD failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec3199978146/fast"
gmake -f CMakeFiles/cmTryCompileExec3199978146.dir/build.make CMakeFiles/cmTryCompileExec3199978146.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3199978146.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3199978146.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:94:20: error: ripemd.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:174: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_rmd160_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:357: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:358: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:317: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:324: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:332: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1272: error: ‘__archive_libmd_ripemd160init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1273: error: ‘__archive_libmd_ripemd160update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1274: error: ‘__archive_libmd_ripemd160final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec3199978146.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec3199978146/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBMD failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec762055209/fast"
gmake -f CMakeFiles/cmTryCompileExec762055209.dir/build.make CMakeFiles/cmTryCompileExec762055209.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec762055209.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec762055209.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:97:17: error: sha.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:186: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:443: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:450: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:458: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1295: error: ‘__archive_libmd_sha1init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1296: error: ‘__archive_libmd_sha1update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1297: error: ‘__archive_libmd_sha1final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec762055209.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec762055209/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBMD failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec4223705718/fast"
gmake -f CMakeFiles/cmTryCompileExec4223705718.dir/build.make CMakeFiles/cmTryCompileExec4223705718.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4223705718.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4223705718.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:100:20: error: sha256.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:206: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:667: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:674: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:682: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1334: error: ‘__archive_libmd_sha256init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1335: error: ‘__archive_libmd_sha256update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1336: error: ‘__archive_libmd_sha256final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec4223705718.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec4223705718/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBMD failed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2460092850/fast"
gmake -f CMakeFiles/cmTryCompileExec2460092850.dir/build.make CMakeFiles/cmTryCompileExec2460092850.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2460092850.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2460092850.dir/check_crypto_md.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:103:20: error: sha512.h: No such file or directory
In file included from /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:244: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1081: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1088: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1096: error: expected ‘)’ before ‘*’ token
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1408: error: ‘__archive_libmd_sha512init’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1409: error: ‘__archive_libmd_sha512update’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1410: error: ‘__archive_libmd_sha512final’ undeclared here (not in a function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
gmake[1]: *** [CMakeFiles/cmTryCompileExec2460092850.dir/check_crypto_md.c.o] Error 1
gmake: *** [cmTryCompileExec2460092850/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Determining size of unsigned short passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec2087269748/fast"
gmake -f CMakeFiles/cmTryCompileExec2087269748.dir/build.make CMakeFiles/cmTryCompileExec2087269748.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2087269748.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2087269748.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/CMAKE_SIZEOF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec2087269748
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2087269748.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2087269748.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec2087269748 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file elf.h exists passed with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1094496876/fast"
gmake -f CMakeFiles/cmTryCompileExec1094496876.dir/build.make CMakeFiles/cmTryCompileExec1094496876.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1094496876.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1094496876.dir/CheckIncludeFile.c.o   -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1094496876
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1094496876.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1094496876.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1094496876 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C++ SOURCE FILE Test run_pic_test succeded with the following output:
Change Dir: /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/gmake "cmTryCompileExec1925906871/fast"
gmake -f CMakeFiles/cmTryCompileExec1925906871.dir/build.make CMakeFiles/cmTryCompileExec1925906871.dir/build
gmake[1]: Entering directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1925906871.dir/src.cxx.o
/usr/bin/g++    -Drun_pic_test   -fPIE -o CMakeFiles/cmTryCompileExec1925906871.dir/src.cxx.o -c /home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.cxx
Linking CXX executable cmTryCompileExec1925906871
/home/lau/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1925906871.dir/link.txt --verbose=1
/usr/bin/g++      -Drun_pic_test    CMakeFiles/cmTryCompileExec1925906871.dir/src.cxx.o  -o cmTryCompileExec1925906871 -rdynamic 
gmake[1]: Leaving directory `/home/lau/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
int main() { return 0;}
